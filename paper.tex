\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{ijcai23}

\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[switch]{lineno}

\usepackage{listings}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{microtype}
\usepackage{amsfonts}
\usepackage{mathtools}

% Comment out this line in the camera-ready submission
\linenumbers

\urlstyle{same}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem*{remark}{Remark}

% PDF Info Is REQUIRED.
% Please **do not** include Title and Author information
\pdfinfo{
/TemplateVersion (IJCAI.2023.0)
}

\lstset{breaklines=true}
\lstset{language=C++,
        basicstyle=\ttfamily,
        stringstyle=\color{red},
        commentstyle=\color{green},
        breaklines=true,
        showstringspaces=false}

\crefname{line}{line}{lines}

\DeclareMathOperator{\Dom}{Dom}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Preds}{Preds}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator*{\argmin}{argmin}

\title{Towards Practical First-Order Model Counting}

% \author{
% First Author$^1$
% \and
% Second Author$^2$\and
% Third Author$^{2,3}$\And
% Fourth Author$^4$
% \affiliations
% $^1$First Affiliation\\
% $^2$Second Affiliation\\
% $^3$Third Affiliation\\
% $^4$Fourth Affiliation
% \emails
% \{first, second\}@example.com,
% third@other.example.com,
% fourth@example.com
% }

\begin{document}

\maketitle

% <= 200 words
\begin{abstract}
\end{abstract}

\section{Introduction}

\paragraph{Contributions.}
\begin{itemize}
  \item Converting the recursive equations into a C++ program, which can then be
        compiled and executed to obtain numerical values (see \cref{sec:cpp}).
  \item Support for infinite precision integers using the GNU Multiple Precision
        Arithmetic Library.
\end{itemize}

\section{Snippets}

\begin{itemize}
  \item The evaluation of base cases is done by simplifying the clauses and then
        using \textsc{Crane} to find the base cases. First, while traversing the
        graph to find the equations, we store two maps objects:
        \texttt{clause\_func\_map} (which stores the mapping from the function
        names to the formulae, whose model count they represent) and
        \texttt{var\_domain\_map} (which stores the mapping from the variable
        names to the domains whose sizes they represent). Then, a particular
        domain is selected (using the algorithm described in previous reports),
        and the clauses are simplified. Then, \textsc{Crane} is called on those
        clauses to evaluate the base cases. After that, we change the function
        names and variable to make it consistent with the previous domain to
        variable mapping, and append these base cases to the set of equations.
  \item Finding a sufficient set of base cases. We know that if, say, on the RHS
        of all equations, the domain size appears as
        $m - c_1, m - c_2, \dots, m - c_k$, then finding
        $f(0, x_1, x_2, \dots)$, $f(1, x_1, x_2, \dots)$,
        $\dots f(m_0, x_1, x_2, \dots)$ for every function $f$, where
        $m_0 = \max(c_1, c_2, \dots c_k) - 1$ forms a sufficient set of base
        cases. Hence, in order to do the same efficiently, we can take that
        domain for which $m_0$ is the minimum, i.e.
        $\argmin(\max(c_1, c_2, \dots c_k))$.
\end{itemize}

\subsection{Bar}

The previous method of base case evaluation on setting a domain to size zero or
one had the following error. In case a domain size was set to zero, it assumed
that those predicates which were deleted from the clauses could take any truth
value over the entire domain and the rest were fully covered by the remaining
clauses.

For example, consider the formula
\begin{equation}\label{eq:example}
  \begin{split}
    \forall x \in \Delta \forall y, z \in \Gamma &: P(x) \lor Q(y, z) \\
    \forall y \in \Gamma^\top &: Q(y, z).
  \end{split}
\end{equation}
In this case, if we set $|\Delta|$ to zero, the transformed formula would be
\[
  \forall y, z \in \Gamma^\top : Q(y, z),
\]
and the set of removed predicates is empty, and hence the model count returned
would be $1$. However, the actual model count should be
$2^{|\Gamma|^2 - |\Gamma^\top|^2}$.

We solve this problem by converting clauses with universal quantifiers over the
empty domain to tautologies, hence retaining all the predicates that have no
argument assigned to the empty domain. For example, we would convert the above
mentioned formula to
\begin{align*}
  \forall y, z \in \Gamma &: Q(y, z) \lor \neg Q(y, z) \\
  \forall y, z \in \Gamma^\top &: Q(y, z)
\end{align*}
The model count returned by this will also consider the truth value of $Q$ over
$y \not \in \Gamma^\top$ or $z \not \in \Gamma^\top$.

\section{Preliminaries}

TODO: Introduce terms: left-hand side (LHS), right-hand side (RHS).

\begin{definition}
  A \emph{function call} is a term of the form
  $f(x_{1} - c_{1}, \dots, x_{n} - c_{n})$ (written $f(\mathbf{x} - \mathbf{c})$
  for short), where $f$ is an $n$-ary function, each $x_{i}$ is a variable, and
  each $c_{i}$ is a non-negative constant.
\end{definition}
% TODO: do I ever use this term for the case when some of the variables don't
% exist?

\begin{definition}
  A \emph{signature} is a term of the form $f(x_{1}, \dots, x_{n})$ (written
  $f(\mathbf{x})$ for short), where $f$ is an $n$-ary function, and each $x_{i}$
  is a variable. The signature of a function call $f(\mathbf{x} - \mathbf{c})$
  is $f(\mathbf{x})$. For example, the signature of $f(x - 1, y - 2)$ is
  $f(x, y)$.
\end{definition}

\begin{remark}
  The LHS of an equation is always a signature.
\end{remark}

For any signature or clause $C$, argument or variable $x$, and number or
constant $t$, we shall write $C[t / x]$ for the result of substituting $t$ for
all occurrences of $x$ in $C$.
% TODO: check if I'm still using this notation in all these cases
% TODO: explain how this works for function calls too

\section{Identifying a Sufficient Set of Base Cases}

\begin{algorithm}[t]
  \caption{Identifying a set of sufficient base cases}\label{alg1}
  \KwIn{set $D$ of dependencies}
  \KwOut{set $B$ of base cases}

  $B \gets \emptyset$\;
  \ForEach{$(f(\mathbf{x}), g(\mathbf{y} - \mathbf{c})) \in D$}{
    \ForEach{$c_{i} \in \mathbf{c}$}{
      \For{$n \gets 0$ \KwTo $c_{i} - 1$}{\label{line:lim}
        $B \gets B \cup \{\, f(\mathbf{x})[x_{i}/n] \,\}$\;\label{line:insert}
        \lIf{$f \ne g$}{$B \gets B \cup \{\, g(\mathbf{y})[y_{i}/n] \,\}$}\label{line:signature}
      }
    }
  }
\end{algorithm}

The following steps were followed while finding the base cases:
\begin{enumerate}
  \item Expand the summations in each equation. Here we expand the summations of
        the form:
        $\sum_{x=0}^{x_{1}}<\textnormal{something}> \cdot [a \le x < b]$, or
        similar inequalities where x is bounded by constants and $a$ and $b$ are
        constants, by substituting the value of $x$ from $a$ to $b-1$. For
        example, we replace
        $\sum_{x=0}^{x_1} \binom{x_{1}}{x} f(x_1 - x) \cdot [0 \le x < 2]$ by
        $\binom{x_{1}}{0} f(x_1) + \binom{x_{1}}{1} f(x_1-1)$.
  \item Next, we find the dependencies of those functions that appear on the
        RHS of any equation. Consider, for example the following set
        of equations:
        \begin{align*}
          f_{0}(m, n) &= f_{1}(m-1, n) + f_{2}(m, n-1)\\
          f_{1}(m, n) &= f_{1}(m-1, n-1) \times f_{2}(m-2, n-1)\\
          f_{2}(m, n) &= 2 \times f_{1}(m-3, n-1)
        \end{align*}
        In this case, the dependencies computed are
        \begin{align*}
          f_{1}(m, n) &\mapsto \{\, f_{1}(m-1, n-1), f_{2}(m, n-1) \,\}\\
          f_{2}(m, n) &\mapsto \{\, f_{1}(m-3, n-1) \,\}
        \end{align*}
  \item Now, we find a domain that has only terms of the form $x-1$ appearing on
        the RHS of the dependencies. The base cases are then calculated by
        setting this domain size to zero. For the above example, $n$ is the
        selected domain, and not $m$ since there are $m-2$ and $m-3$ terms
        appearing in the arguments.
\end{enumerate}

\paragraph{Limitations of the current implementation.} Ideally, we should
calculate the base cases by finding the base cases up to
$\max(c_{1}, c_{2}, \dots) - 1$. However, currently only empty and singleton
domains are supported.

\begin{itemize}
  \item \cref{line:lim}: the limit is 2 for the arg $(x-3)$.
  \item \cref{line:insert} for $f(\mathbf{x}) = f(x_{1}, x_{2})$,
        $\text{arg} = x$, and $n = 0$, add $f(0, x_{2})$ to $B$.
  \item note that on \cref{line:signature} it is the signature and not the
        original function call.
\end{itemize}

The algorithm is described as \cref{alg1}. Here, a dependency is a pair
$(a, b)$, where $a$ is the signature on the LHS of each equation and $b$ is each
function call on the RHS of the equation. For example, for the equations
\begin{align*}
  f(m, n) &= g(m-1, n) + f(m-2, n-1)\\
  g(m, n) &= f(m-1, n-2) + g(m-1, n-1)
\end{align*}
the dependencies are
\begin{multline*}
  (f(m, n), g(m - 1, n)), (f(m, n), f(m - 2, n - 1)),\\
  (g(m, n), f(m - 1, n - 2), g(m - 1, n - 1)).
\end{multline*}

\section{Algorithm to Transform CNF Based on Domain Sizes}

\begin{algorithm}[t]
  \caption{Transforming Formulas Based on Domain Sizes}\label{alg2}
  \KwIn{formula $\phi$, domain $\Delta$, target domain size $n \in \{\, 0, 1 \,\}$, domain size function $|\cdot|$}
  \KwOut{formula $\phi'$}
  $P^{-} \gets \emptyset$; $P^{+} \gets \emptyset$; $\phi' \gets \emptyset$\;
  \uIf{$|\Delta| = 0$}{
    \ForEach{clause $C \in \phi$}{
      \uIf{$\Delta \in \Doms(C)$}{
        $P^{-} \gets P^{-} \cup \Preds(C)$\;
      }
      \Else{
        $P^{+} \gets P^{+} \cup \Preds(C)$\;
        $\phi' \gets \phi' \cup \{\, C \,\}$\;
      }
    }
    $P^{-} \gets P^{-} \setminus P^{+}$\;
  }
  \ElseIf{$|\Delta| = 1$}{
    $c \gets$ a new constant symbol\;
    \ForEach{clause $C \in \phi$}{
      $C' \gets C$\;
      \ForEach{$v \in \Vars(C)$ with $\Dom(v) = \Delta$}{
        $C' \gets C'[c / v]$\;
      }
      $\phi' \gets \phi' \cup \{\, C' \,\}$\;
    }
  }
\end{algorithm}
% TODO: the removed empty domains should be replaced by smoothing/tautological
% constructions

% TODO: either the target domain size or the domain size function needs to go

\begin{itemize}
  \item Formulas are in CNF. Formulas are (multi) sets of clauses.
  \item $P^{-}$ --- removed predicates
  \item $P^{+}$ --- retained predicates
  \item $\phi'$ --- transformed version of $\phi$
  \item $C'$ --- transformed version of clause $C$
  \item For any clause $C$, let $\Doms(C)$, $\Preds(C)$, and $\Vars(C)$ denote
        respectively the set of domains, predicates, and variables in $C$. For
        any variable $v$, let $\Dom(v)$ denote its domain. Note that, for any
        clause $C$, we have that
        $\Doms(C) = \{\, \Dom(v) \mid v \in \Vars(C) \,\}$. Similarly, for any
        predicate $P$, let $\Doms(P)$ denote the set of domains associated with
        $P$.
\end{itemize}

We use \cref{alg2} to find the transformed formula corresponding to each base
case obtained using \cref{alg1} and call \textsc{Crane} on the formula to obtain
the required base cases.

\section{Generating C++ Code}\label{sec:cpp}

% TODO: The report has some (long) examples of formulas being transformed into
% programs perhaps suitable for supplementary material.

The target is to generate C++ code that can evaluate numerical values of the
model counts based on the equations generated by \textsc{Crane}. There are two
ways to do the same.
\begin{enumerate}
  \item Generate C++ code by traversing the FCG, similar to what is done in
        \texttt{OutputVisitor.scala}.
  \item Parse the equations generated by \textsc{Crane} after simplifying in
        wolfram and then generate C++ code.
\end{enumerate}

The problem with the first approach is that, while generating base cases, the
subsequent calls to \textsc{Crane} do not necessarily have the same meanings for
the function arguments and the functions. For example, if
$f_{1}(x_{0}, x_{1}, x_{2})$ represents the model count of a constrained formula
$\phi$, where $f_{1}$ is an auxiliary formula and $x_{0} = |A|$, $x_{1} = |B|$,
$x_{2} = |C|$, and $A$, $B$, $C$ are domains and we want to evaluate
$f_{1}(0, x_{1}, x_{2})$ (i.e., set $|A| = 0$), then \textsc{Crane} may return
the required model count as $f_{0}(x_{0}, x_{1})$, where $x_{0} = |B|$ and
$x_{1} = |C|$. We will then need to translate this to $f_{1}(0, x_{1}, x_{2})$.
Also, the second approach can be done in linear time in the length of the
formula using
the
\href{https://en.wikipedia.org/wiki/Shunting_yard_algorithm#:~:text=In%20computer%20science%2C%20the%20shunting,abstract%20syntax%20tree%20(AST).}{Shunting
  Yard Algorithm}. Hence, we stick to the second approach.

\subsection{Our Approach}

The translation of a set $E$ of equations into a C++ program works as follows.

First, we create a cache for each function in $E$. This is implemented as a
multi-dimensional vector containing objects of \texttt{class cache\_elem}
defined as shown in the example code. The default initialization of this object
is to $-1$ which is useful for recognizing unevaluated cases.

Next, we create a function definition for the LHS of each equation in $E$,
including all functions and base cases. The signatures of these functions is
decided as follows. A function call containing only variable arguments is named
as the function itself, and ones with constants in their arguments are suffixed
with a string that contains \texttt{'x'} at the $i$th place if the $i$th
argument is variable and the $i$th argument if that argument is a constant. For
example, $f(x_{1}, x_{2}, x_{3})$ is declared as \texttt{int f(int x1, int x2,
  int x3);} and $f(1, x_{2}, x_{3})$ is declared as \texttt{int f\_1xx(int x2,
  int x3);} (the constant arguments are removed from the signature).

The RHS of each equation in $E$ is used to define the body of the equation
corresponding to the LHS of that equation. The function body (for a function
\texttt{func} corresponding to equation $e$) is formed as follows.
\begin{enumerate}
  \item First, we check if the evaluation is already present in the cache. If
        so, then we return the cache element. The cache accesses are done using
        the \texttt{get\_elem} function (definition given in the example), which
        resizes the cache if the accessed index is out of range.
  \item If the element is absent, then we decide if the arguments corresponding
        to $e$ or one of the functions corresponding to the base cases, based on
        the value of the arguments. If it corresponds to the base cases, then we
        directly call the base case function and return its value. Else, we
        evaluate the value using the RHS, store the evaluated value in the cache
        and return the evaluated value. Note that in this step, we only call the
        base case function with one more constant argument that \texttt{func}.
        For example, \texttt{f0(x, y)} would call \texttt{f0\_0x(y)} if
        \texttt{x == 0} and \texttt{f0\_x0(x)} if \texttt{y == 0}.
  \item In order to translate the RHS, we convert $\sum_{x=a}^{b} \texttt{exp}$
        to
\begin{lstlisting}
([y,z,...](){
    int sum = 0;
    for(int x = a; x <= b; x++)
        sum += exp;
    return sum;
})()
\end{lstlisting}
        where $y, z, \dots$ are the free variables present in \texttt{exp}.
\end{enumerate}

\bibliographystyle{named}
\bibliography{paper}

\end{document}

