\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\urlstyle{same}

\usepackage[backgroundcolor=lightgray]{todonotes}
\usepackage{listings}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{microtype}
\usepackage{mathtools}
\usepackage{forest}
\usepackage{siunitx}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage[inline]{enumitem}

\usetikzlibrary{arrows.meta}

\newtheorem{theorem}{Theorem}
\newtheorem{fact}{Fact}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

% TODO: 9 pages!!!

\pdfinfo{
/TemplateVersion (KR.2022.0, KR.2023.0, KR.2024.0)
}

\forestset{
  sn edges/.style={for tree={edge={-Latex}}}
}

\lstset{breaklines=true}
\lstset{language=C++,
        basicstyle=\ttfamily,
        stringstyle=\color{red},
        commentstyle=\color{green},
        breaklines=true,
        showstringspaces=false}

\crefname{line}{line}{lines}
\crefalias{formula}{equation}
\crefname{formula}{Clause}{Clauses}
\creflabelformat{formula}{#2\textup{(#1)}#3}

\DeclareMathOperator{\Dom}{Dom}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator{\GDR}{GDR}

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\newcommand{\expr}{\mathtt{expr}}
\newcommand{\Ctwo}{$\mathsf{C}^{2}$}
\newcommand{\FO}{$\mathsf{FO}$}
\newcommand{\UFO}{$\mathsf{UFO}^{2} + \mathsf{EQ}$}

\newcommand{\Cranetwo}{\textsc{Crane}~2}

\SetKwFunction{Crane}{Compile}
\SetKwFunction{Propagate}{Propagate}
\SetKwFunction{FindBaseCases}{FindBaseCases}

\title{Towards Efficient First-Order Model Counting}

% TODO: check if this follows the formatting guidelines
\author{%
Ananth K. Kidambi$^1$\and
Guramrit Singh$^1$\and
Paulius Dilkas$^2$\and
Kuldeep S. Meel$^3$ \\
\affiliations
$^1$Indian Institute of Technology Bombay, India\\
$^2$National University of Singapore, Singapore\\
$^3$University of Toronto, Canada\\
\emails
\{210051002, 210050061\}@iitb.ac.in,
paulius.dilkas@nus.edu.sg,
meel@cs.toronto.edu
}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}

\todo[inline,caption={}]{
  \begin{itemize}
    \item describe which compilation rules are currently greedy or non-greedy
    \item my agenda has a plan for proving completeness for $\mathbf{C}^{2}$
    \item Can I prove that my domain recursion can always simulate the domain
          recursion of \textsc{ForcLift}?
  \end{itemize}
}

\paragraph{Papers to cite.}
\begin{itemize}
  \item original domain recursion~\cite{DBLP:conf/nips/Broeck11}
  \item recent overview paper~\cite{DBLP:conf/ijcai/Kuzelka23}
  \item conjecturing recurrence relations~\cite{DBLP:conf/ilp/BarvinekB0ZK21}
  \item algorithms
  \begin{itemize}
    \item \textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11}
    \item \textsc{Crane}~\cite{DBLP:conf/kr/DilkasB23}
    \item \textsc{FastWFOMC}~\cite{DBLP:conf/uai/BremenK21}
    \item approximate~\cite{DBLP:conf/ijcai/BremenK20}
  \end{itemize}
  \item liftable fragments (TODO: perhaps good sources of benchmarks?)
  \begin{itemize}
    \item \Ctwo~\cite{DBLP:journals/jair/Kuzelka21}
    \item tree axioms~\cite{DBLP:journals/ai/BremenK23}
    \item linear order axioms~\cite{DBLP:conf/aaai/TothK23}
  \end{itemize}
  \item applications
  \begin{itemize}
    \item extensions to
          sampling~\cite{DBLP:conf/aaai/WangB0K22,DBLP:conf/lics/WangP0K23}
    \item discovery of combinatorial
          sequences~\cite{DBLP:conf/ijcai/SvatosJT0K23}
  \end{itemize}
\end{itemize}

% TODO: make sure to not call \Crane2 \textsc{Crane}

\paragraph{Changes to the compilation process.}
\begin{itemize}
  \item We make the FCGs satisfy the following property. For every domain
        $\Delta$, for every directed path $P$ without Ref nodes, the number of
        atom counting or (generalised) domain recursion or independent partial
        grounding operations on $\Delta$ on $P$ is at most one.
  \item when checking whether recursion is possible between a source and a
        target formula, the target formula (maybe the source formula as well?)
        must not include a domain as well as its subdomain. This might be
        equivalent to the formula being `unshattered'. Such formulas could be
        seen as transitory, and allowing such recursive calls leads to FCGs that
        I cannot make sense of.
\end{itemize}

\paragraph{Proof of correctness (leave for later).}
\begin{enumerate}
  \item Define what it means for a formula to be \emph{consistent}.
        \begin{itemize}
          \item The formula (including the mapping of constants to their
                domains) does not mention a domain together with its subdomain
                (i.e., all mentioned domains are pairwise disjoint).
                Specifically, we can't have a subdomain together with its parent
                domain or a subdomain together with a constant that belongs to
                its parent domain.
          \item The target of \texttt{Ref} must also be a consistent formula.
          \item The initial formula is consistent by definition.
        \end{itemize}
  \item Aim to show that \Cranetwo{} works correctly on all consistent formulas.
  \item Prove that, whenever some compilation rule makes the formula $\phi$
        inconsistent, greedy compilation rules will make $\phi$ consistent again
        before $\phi$ encounters non-greedy compilation rules that depend on
        $\phi$ being consistent.
        \begin{itemize}
          \item In particular, prove that shattering and unit propagation will
                always eliminate the parent domain of the domains introduced by
                atom counting.
          \item Constraint removal only applies when it can eliminate the parent
                domain entirely.
          \item Prove this for a particular assumption about which compilation
                rules are set to be greedy. For the greedy algorithm, although
                all rules are applied in a greedy manner, we still assume that
                greedy rules will be applied before non-greedy rules.
        \end{itemize}
  \item In particular, independent partial groundings and atom counting are the
        two classical rules that require the formula to be shattered.
  \end{enumerate}

 % TODO: Crane2 uses itself instead of Crane. Not really. By 'Crane', here I
 % mean the process of turning logical formulas into equations. Later on, I use
 % 'Crane' to refer to Crane2. Maybe rename this use of 'Crane' to something
 % else?
\begin{figure*}[t]
  \centering
  \begin{tikzpicture}
    \node at (0, 0) (formula) {$\phi$};
    \node[draw,rounded rectangle] at (3, 0) (alg1) {\Cref{alg:main}};
    \node[draw,rounded rectangle] at (6, 0) (simplification) {Simplification};
    \node[draw,rounded rectangle] at (9, 0) (compilation) {Compilation};

    \node[draw,rounded rectangle,dashed] at (12, 0) (cpp) {C++ code};
    \node at (12, -1) (sizes) {Domain sizes};

    \node at (15, 0) (count) {Model count};

    \node[draw,rounded rectangle] at (3, -2) (alg2) {\Cref{alg1}};
    \node[draw,rounded rectangle,left = 0.1cm of alg2] (crane) {\textsc{Crane}};
    \node[draw,rounded rectangle,right = 0.1cm of alg2] (alg3) {\Cref{alg2}};

    \node[draw,fit={(alg1) (simplification) (compilation) (crane) (alg2) (alg3)},inner ysep=7pt,yshift=5pt] {};
    \node at (1.1, 0.5) {\Cranetwo};

    \draw[-Latex] (formula) -- (alg1);
    \draw[-Latex] (alg1) -- node[above] {$\mathcal{E}$} (simplification);
    \draw[-Latex] (simplification) -- node[above] {$\mathcal{E}'$} (compilation);
    \draw[-Latex] (compilation) -- (cpp);
    \draw[-Latex] (sizes) -- (cpp);
    \draw[-Latex] (cpp) -- (count);

    \draw[-Latex,dashed] (alg1) -- node[midway,left] {uses} (crane);
    \draw[-Latex,dashed] (alg1) -- node[midway] {uses} (alg2);
    \draw[-Latex,dashed] (alg1) -- node[midway,right] {uses} (alg3);
  \end{tikzpicture}
  \caption{Using \Cranetwo{} to compute the model count of formula $\phi$.\ The
    formula is compiled into a set of equations $\mathcal{E}$, which are then
    algebraically simplified and compiled to a C++ program. This program can
    then be run with different command line arguments to compute the model count
    of $\phi$ for various domain sizes.}
\end{figure*}

\paragraph{Contributions (outdated).}
\begin{itemize}
  \item \Cref{sec:identifying}
  \item \Cref{sec:simplifying}
  \item Converting the recursive equations into a C++ program, which can then be
        compiled and executed to obtain numerical values (see \cref{sec:cpp}).
  \item Support for infinite precision integers using the GNU Multiple Precision
        Arithmetic Library.
  \item Some experiments vs FastWFOMC
  \item A proof of completeness
\end{itemize}

\Cref{sec:identifying,sec:cpp} deal with algebraic constructs whereas
\cref{sec:simplifying} deals with logic.

\section{Preliminaries}

\subsection{Algebra}

\paragraph{Notation.}
We write $\expr{}$ for an arbitrary algebraic expression. For any signature or
clause $C$, argument or variable $x$, and number or constant $t$, we shall write
$C[t / x]$ for the result of substituting $t$ for all occurrences of $x$ in $C$.

\begin{itemize}
  \item Variables in uppercase
  \item Domains in uppercase Greek
  \item Constant and predicate symbols in lowercase
  \item Clauses written on separate lines are implicitly conjoined
  \item For weights, for any predicate symbol $p$, we write
        $w^{+}(p), w^{-}(p) \in \mathbb{R}$ for its positive and negative
        weights, respectively. All weights not explicitly acknowledged are
        assumed to be equal to one.
\end{itemize}

\todo[inline,caption={}]{
  \begin{itemize}
    \item check if I'm still using this notation in all these cases
    \item explain how this works for function calls too
    \item introduce WFOMC as a problem
  \end{itemize}
}

\begin{definition}
  A \emph{function call} is a term of the form
  $f(x_{1} - c_{1}, \dots, x_{n} - c_{n})$ (written $f(\mathbf{x} - \mathbf{c})$
  for short), where $f$ is an $n$-ary function, each $x_{i}$ is a variable, and
  each $c_{i}$ is a non-negative constant.
\end{definition}
\todo[inline]{do I ever use this term for the case when some of the variables
  don't exist?}

\begin{definition}
  A \emph{signature} is a term of the form $f(x_{1}, \dots, x_{n})$ (written
  $f(\mathbf{x})$ for short), where $f$ is an $n$-ary function, and each $x_{i}$
  is a variable. The signature of a function call $f(\mathbf{x} - \mathbf{c})$
  is $f(\mathbf{x})$. For example, the signature of $f(x - 1, y - 2)$ is
  $f(x, y)$.
\end{definition}

\begin{definition}
  An \emph{equation} is always of the form $f(\mathbf{x}) = \expr{}$, where
  $f(\mathbf{x})$ is a signature, and $\expr{}$ is an algebraic expression.
  Henceforth, we call $f(\mathbf{x})$ and $\expr{}$ the left-hand side (LHS) and
  the right-hand side (RHS) of the equation, respectively.
\end{definition}
\todo[inline,caption={}]{
  give some examples of formulas that:
  \begin{itemize}
    \item introduce new variables,
    \item call the function itself,
    \item call some other function, and
    \item is more nested than just a sum.
  \end{itemize}
}

\begin{definition}
  A \emph{base case} is a function call where all arguments are either variables
  or constants (i.e., there is no subtraction within any argument), and there is
  at least one constant. We denote a base case in the same way as a signature,
  e.g., $f(\mathbf{x})$.
\end{definition}

\subsection{Logic}

\todo[inline,caption={}]{
  \begin{itemize}
    \item What notation am I using for FOL? Introduce equality cardinality
          constraints, counting quantifiers, etc.
    \item Need (W)FOMC semantics. What is an interpretation? What is a model?
    \item Should table caption go above or below the table?
    \item Define terms.
    \item Maybe say ``structure'' instead of interpretation?
    \item What's the right table heading capitalization for KR?
    \item Should I say ``sort'' instead of domain everywhere?
  \end{itemize}
}

\begin{table*}
  \centering
  \begin{tabular}{llclll}
    \toprule
    Logic & Sorts & Constants & Variables & Quantifiers & Additional atomic constraints\\
    \midrule
    \FO & one or more & \cmark & unlimited & $\forall$, $\exists$ & $s = t$\\
    \Ctwo & one & \xmark & two & $\forall$, $\exists$, $\exists^{= k}$, $\exists^{\le k}$, $\exists^{\ge k}$ & ---\\
    \UFO & one & \xmark & two & $\forall$ & $|p| = m$\\
    \bottomrule
  \end{tabular}
  \caption[]{A comparison of the three logics used in WFOMC in terms of:
    \begin{enumerate*}[label=(\roman*)]
      \item the number of sorts,
      \item support for constants,
      \item the maximum number of variables,
      \item allowed quantifiers, and
      \item atomic constructions in addition to those of the form $p(t_{1}, \dots, t_{n})$ for some predicate symbol $p$ and terms $t_{1}, \dots, t_{n}$.
    \end{enumerate*}
    Here:
    \begin{enumerate*}[label=(\roman*)]
      \item $k$ and $m$ are non-negative integers, the latter of which can depend on the domain size,
      \item $p$ is a predicate symbol, and
      \item $s$ and $t$ are terms.
    \end{enumerate*}
  }\label{tbl:logics}
\end{table*}

\paragraph{Three types of logics}
\begin{itemize}
  \item All three logics are function-free.
  \item Domains are always assumed to be finite.
  \item See \cref{tbl:logics} for a detailed comparison. \FO{} is used as the
        input format for \textsc{ForcLift} and its extensions \textsc{Crane} and
        \Cranetwo{}. \Ctwo{} is used in the literature on \textsc{FastWFOMC} and
        related methods (TODO: citations). \UFO{} is the input format supported
        by a privately-obtained version of \textsc{FastWFOMC}. Note that the
        publicly available version does not support any cardinality constraints.
  \item In the case of \textsc{ForcLift} and its extensions, support for a
        formula as valid input does not imply that the algorithm will be able to
        compile the formula into a circuit or graph suitable for lifted model
        counting. However, it is known that \textsc{ForcLift} compilation is
        guaranteed to succeed on any \FO{} formula without constants and with at
        most two variables (TODO: citation).
\end{itemize}

A \emph{formula} is a set of clauses. A \emph{clause} is of the form
$\forall x_{1} \in \Delta_{1}\forall x_{2} \in \Delta_{2}\dots\forall x_{n} \in \Delta_{n} \phi(x_{1}, x_{2}, \dots, x_{n})$,
where $\phi$ is a disjunction of literals that only contain variables
$x_{1}, \dots, x_{n}$ (and any constants). A \emph{literal} is either an atom or
its negation. An \emph{atom} is of the form $P(t_{1}, \dots, t_{m})$, where $P$
is a predicate, and $t_{1}, \dots, t_{m}$ are terms. A \emph{term} is either a
variable or a constant.

\todo[inline]{explain set-based notation for a clause (iterating over all
  literals)}

For any clause or literal $l$, let $\Vars(l)$ denote the set of variables in
$l$.

For any (bound) variable $v$, let $\Dom(v)$ denote the domain over which $v$ is
quantified. For a literal $l$,
$\Doms(l) \coloneqq \{\, \Dom(v) \mid v \in \Vars(l) \,\}$. Similarly, for any
clause $C$, let $\Doms(C) = \{\, \Dom(v) \mid v \in \Vars(C) \,\}$.

\section{Completing the Definitions of Recursive Functions}\label{sec:main}

\begin{algorithm}[t]
  \caption{The core part of \Cranetwo{} that compiles a formula...}\label{alg:main}% TODO: start here
  \KwIn{formula $\phi$}
  \KwOut{set $\mathcal{E}$ of equations}
  $(\mathcal{E}, \mathcal{F}, \mathcal{D}) \gets \Crane{$\phi$}$\;
  \ForEach{base case $f(\mathbf{x}) \in \FindBaseCases{$\mathcal{E}$}$}{
    $\psi \gets \mathcal{F}(f)$\;
    \ForEach{$i$ such that $x_{i}$ is a constant}{
      $\psi \gets \Propagate{$\psi$, $\mathcal{D}(f, i)$, $x_i$}$\;
    }
    $(\mathcal{E}', \text{\textunderscore}, \text{\textunderscore}) \gets \Crane{$\psi$}$\;
    $\mathcal{E} \gets \mathcal{E} \cup \mathcal{E}'$\;
  }
\end{algorithm}

See \cref{alg:main}.

We write \Crane for a slight modification of the original \textsc{Crane} that
compiles a formula $\phi$ into:
\begin{itemize}
  \item a set $\mathcal{E}$ of equations,
  \item a map $\mathcal{F}$ from function names to formulas, and
  \item a map $\mathcal{D}$ from function names and parameter indices to
        domains.
\end{itemize}

% TODO: update: crane or crane2
The evaluation of base cases is done by simplifying the clauses and then using
\textsc{Crane} to find the base cases. A particular domain is selected, and the
clauses are simplified. Then, \textsc{Crane} is called on those clauses to
evaluate the base cases. After that, we change the function names and variable
to make it consistent with the previous domain to variable mapping, and append
these base cases to the set of equations.

\todo[inline,caption={}]{extend it to work with base cases that are themselves
  recursive}

\subsection{Identifying a Sufficient Set of Base Cases}\label{sec:identifying}

\begin{algorithm}[t]
  \caption{\protect\FindBaseCases{$\mathcal{E}$}}\label{alg1}
  \KwIn{set $\mathcal{E}$ of equations}
  \KwOut{set $\mathcal{B}$ of base cases}

  $\mathcal{B} \gets \emptyset$\;
  \ForEach{equation $(f(\mathbf{x}) = \expr{}) \in \mathcal{E}$}{
    \ForEach{function call $f(\mathbf{x} - \mathbf{c}) \in \expr{}$}{\label{line:functioncall}
      \ForEach{$c_{i} \in \mathbf{c}$}{
        \For{$n \gets 0$ \KwTo $c_{i} - 1$}{\label{line:lim}
          $\mathcal{B} \gets \mathcal{B} \cup \{\, f(\mathbf{x})[x_{i}/n] \,\}$\;\label{line:insert}
        }
      }
    }
  }
\end{algorithm}

The algorithm is described as \cref{alg1}. We know that if, say, on the RHS of
all equations, the domain size appears as $m - c_1, m - c_2, \dots, m - c_k$,
then finding $f(0, x_1, x_2, \dots)$, $f(1, x_1, x_2, \dots)$,
$\dots f(m_0, x_1, x_2, \dots)$ for every function $f$, where
$m_0 = \max(c_1, c_2, \dots c_k) - 1$ forms a sufficient set of base cases.
Hence, in order to do the same efficiently, we can take that domain for which
$m_0$ is the minimum, i.e. $\argmin(\max(c_1, c_2, \dots c_k))$. Ideally, we
should calculate the base cases by finding the base cases up to
$\max(c_{1}, c_{2}, \dots) - 1$. However, currently only empty and singleton
domains are supported.

First, expand the summations in each equation. Here we expand the summations of
the form: $\sum_{x=0}^{x_{1}} \expr{} \cdot [a \le x < b]$ or similar
inequalities where $x$ is bounded by constants and $a$ and $b$ are constants, by
substituting the value of $x$ from $a$ to $b-1$. For example, we replace
$\sum_{x=0}^{x_1} \binom{x_{1}}{x} f(x_1 - x) \cdot [0 \le x < 2]$ by
$\binom{x_{1}}{0} f(x_1) + \binom{x_{1}}{1} f(x_1-1)$.

\begin{itemize}
  \item \cref{line:insert} for $f(\mathbf{x}) = f(y, z)$, $x_{i} = y$, and
        $n = 0$, add $f(y, z)[y/0] = f(0, z)$ to $\mathcal{B}$.
\end{itemize}

\begin{theorem}
  Under the following assumptions, \cref{alg1} is guaranteed to return a
  sufficient set of base cases:
  \begin{itemize}
    \item there is no mutual recursion
    \item each function $f$ has exactly one equation with $f$ on the LHS;
    \item in the recursive definition of function $f(x_{1},\dots,x_{n})$, the
          $i$-th argument of each call to $f$ on the RHS is of the form
          $x_{i} - c_{i}$, where:
          \begin{itemize}
            \item $c_{i} \ge 0$ for all $i$, and
            \item $c_{i} > 0$ for at least one $i$.
          \end{itemize}
  \end{itemize}
\end{theorem}

\begin{example}
  For an equation $f(m, n) = 2 \times f(m-1, n)$, \cref{alg1} returns $f(0, n)$.
\end{example}

NOTE: function calls such as $f(n-m)$ and $f(n-m-1)$ are ignored.

\subsection{Propagating Domain Size Assumptions}\label{sec:simplifying}

\begin{algorithm}[t]
  \caption{\protect\Propagate{$\phi$, $\Delta$, $n$} TODO: find the source code and check: (1) what we're doing with unit clauses, (2) whether we just randomly pick any literal to negate}\label{alg2}
  \KwIn{formula $\phi$, domain $\Delta$, domain size $n \in \{\, 0, 1 \,\}$}
  \KwOut{formula $\phi'$}
  $\phi' \gets \emptyset$\;
  \uIf{$n = 0$}{
    \ForEach{clause $C \in \phi$}{
      \lIf{$\Delta \not\in \Doms(C)$}{$\phi' \gets \phi' \cup \{\, C \,\}$}
      $C' \gets \{\, l \in C \mid \Delta \not\in \Doms(l) \,\}$\;
      \If{$\Delta \in \Doms(C)$ {\bf and} $C' \ne \emptyset$}{
        $l \gets \text{an arbitrary literal in } C'$\;\label{line:smoothing1}
        $\phi' \gets \phi' \cup \{\, C' \cup \{\, \neg l \,\} \,\} $\;\label{line:smoothing2}
      }
    }
  }
  \Else{
    $c \gets$ a new constant symbol\;
    \ForEach{clause $C \in \phi$}{
      $C' \gets C$\;
      \ForEach{$v \in \Vars(C)$ with $\Dom(v) = \Delta$}{
        $C' \gets C'[c / v]$\;
      }
      $\phi' \gets \phi' \cup \{\, C' \,\}$\;
    }
  }
\end{algorithm}

We use \cref{alg2} to find the transformed formula corresponding to each base
case obtained using \cref{alg1} and call \textsc{Crane} on the formula to obtain
the required base cases.
% TODO: or crane 2?

\begin{itemize}
  \item Clauses where all literals have variables quantified over the empty
        domain are still removed.
  \item $C'$ is guaranteed to be non-empty.
  \item \Cref{line:smoothing1,line:smoothing2} are explained in
        \cref{sec:smoothingbase}.
\end{itemize}

\section{Smoothing}

Goal of smoothing: whenever rules such as unit propagation or
inclusion-exclusion (maybe just these two?) eliminate the consideration of some
ground atoms, smoothing nodes should be inserted `at the same level' so that
these ground atoms are still considered when counting. Note that conjunction
nodes are irrelevant here because multiplication is associative. `At the same
level' means that, e.g., if some ground atoms were eliminated from consideration
before/after performing independent partial grounding, then the smoothing node
should also appear before/after the independent partial grounding node.

\todo[inline,caption={}]{
  \begin{itemize}
    \item Can I prove that the additions to smoothing outlined in the rest of
          this section `do the right thing'?
    \item I could include more info about the smoothing algorithm that didn't
          make it into the previous paper.
  \end{itemize}
}

\subsection{Smoothing for Base Cases}\label{sec:smoothingbase}

\paragraph{Key point.}
If there is a predicate $p$ that has nothing to do with domain $\Delta$, make
sure that $p$ remains as part of the formula even if all clauses with $p$ can be
removed. Which literal is picked on \cref{line:smoothing1} of \cref{alg2} is not
important because any choice achieves the same goal: constructing a clause that
mentions the same predicates as $C'$ and is satisfied by any interpretation.

\begin{fact}
  Assuming that domain $\Delta$ is empty, any clause that contains
  `$\forall x \in \Delta$' (for any variable $x$) is vacuously satisfied by all
  interpretations.
\end{fact}

For example, consider the formula
\begin{align}
  \forall x \in \Delta \forall y, z \in \Gamma &: P(x) \lor Q(y, z)\label[formula]{eq:example1}\\
  \forall y, z \in \Gamma' &: Q(y, z)\label[formula]{eq:example2}
\end{align}
and assume that $\Gamma' \subseteq \Gamma$. In this case, if we set $|\Delta|$
to zero and remove clauses with variables quantified over $\Delta$, we get
\begin{equation}\label[formula]{eq:simplified}
  \forall y, z \in \Gamma' : Q(y, z),
\end{equation}
but the model count of \cref{eq:simplified} is one. However, the actual model
count should be $2^{|\Gamma|^2 - |\Gamma'|^2}$. That is, $Q$ as a relation is a
subset of $\Gamma \times \Gamma$. While \cref{eq:example1} becomes vacuously
true, \cref{eq:example2} fixes the value of $Q$ over
$\Gamma' \times \Gamma' \subseteq \Gamma \times \Gamma$. Hence, the number of
different values that $Q$ can take is
$|(\Gamma \times \Gamma) \setminus (\Gamma' \times \Gamma')| = |\Gamma|^{2} - |\Gamma'|^{2}$.

We address this issue by converting clauses with universal quantifiers over the
empty domain to tautologies, hence retaining all the predicates that have no
argument assigned to the empty domain. For example, we would convert
\cref{eq:example1,eq:example2} to
\begin{align*}
  \forall y, z \in \Gamma &: Q(y, z) \lor \neg Q(y, z) \\
  \forall y, z \in \Gamma' &: Q(y, z).
\end{align*}
The model count returned by this will also consider the truth value of $Q$ over
$y \in \Gamma \setminus \Gamma'$ or $z \in \Gamma \setminus \Gamma'$.

\subsection{Stage 1: Propagating Unit Clauses `Upwards'}

\begin{description}
  \item[\texttt{Ref}.] During smoothing, when unit clauses (a.k.a.\ variables)
        are propagated in the opposite direction of the FCG arcs (i.e.,
        `upwards'), when visiting a \texttt{Ref} node, these clauses are
        translated using the domain map of the \texttt{Ref} node. For example,
        if the domain map include $\Delta \mapsto \Delta'$, and the unit clause
        mentions $\Delta$, then replace it by $\Delta'$.
  \item[Constraint removal.] Do reverse constraint removal. Assuming that
        domain $\Delta$ with constraints $X \ne c$ (for some constant
        $c \in \Delta$) were replaced with domain $\Delta'$, replace each
        $\forall X \in \Delta'\text{. }\phi(X)$ with
        $\forall X \in \Delta\text{. }X \ne c \Rightarrow \phi(X)$.
  \item[Domain recursion.] Suppose the domain recursion node introduces constant
        $x \in \Delta$. For each unit clause received from the child node,
        replace each occurrence of $\phi(x)$ or $\forall X \in \Delta\text{.
        } X \ne x \Rightarrow \phi(X)$ with $\forall X \in \Delta\text{.
        }\phi(X)$. This can be seen as a claim about what ground atoms the
        domain recursion node \emph{should} cover (or a temporary assumption).
        If the relevant subgraph indeed covers those ground atoms, Stage~2 will
        do nothing. Otherwise, smoothing nodes will be added below the domain
        recursion node to cover the difference between what was propagated from
        the domain recursion node and what was received from the child node.
\end{description}
\todo[inline]{Add examples of both cases, with figures.}

\subsection{Stage 2: Adding Smoothing Nodes}

% TODO
% \item Whenever the set of unit clauses received from the child node contains two
% formulas $\phi(x)$ and $\forall X \in \Delta\text{.
% } X \ne x \Rightarrow \phi(X)$ (i.e., the only difference between the two
% formulas is that one has the constant $x$ whereas the other one has a variable
% $X \ne x$), merge them into $\forall X \in \Delta\text{. }\phi(X)$.

\begin{description}
  \item[\texttt{Ref}:] nothing.
  \item[Constraint removal:] nothing.
  \item[Domain recursion:]
        \begin{enumerate}
          \item Whenever the set of unit clauses of the child node contains two
                formulas $\phi(x)$ and $\forall X \in \Delta\text{.
                } X \ne x \Rightarrow \phi(X)$ (i.e., the only difference
                between the two formulas is that one has the constant $x$
                whereas the other one has a variable $X \ne x$), merge them into
                $\forall X \in \Delta\text{. }\phi(X)$.
          \item Add smoothing nodes below the domain recursion node for the
                difference between the unit clauses assigned to the domain
                recursion node during Stage 1 and the unit clauses of the child
                node post-processed by the step above. For example, if the child
                node `covers' only $p(x)$, then Stage 1 assigns
                $\forall X \in \Delta\text{. }p(X)$ to the domain recursion
                node. The smoothing node below the domain recursion node then
                has the clause $\forall X \in \Delta\text{.
                } X \ne x \Rightarrow p(X)$.
        \end{enumerate}
\end{description}

\todo[inline]{Can I formally define what is meant by `difference'?}

\section{Generating C++ Code}\label{sec:cpp}

The target is to generate C++ code that can evaluate numerical values of the
model counts based on the equations generated by \textsc{Crane}. We achieve this
by parsing the equations generated by \textsc{Crane}, simplifying them, and then
generating C++ code. This approach can be done in linear time in the length of
the formula using
the
\href{https://en.wikipedia.org/wiki/Shunting_yard_algorithm#:~:text=In%20computer%20science%2C%20the%20shunting,abstract%20syntax%20tree%20(AST).}{Shunting
  Yard Algorithm}.

The translation of a set $\mathcal{E}$ of equations into a C++ program works as
follows.

First, we create a cache for each function in $\mathcal{E}$. This is implemented
as a multi-dimensional vector containing objects of \texttt{class cache\_elem}
defined as shown in the example code. The default initialization of this object
is to $-1$ which is useful for recognizing unevaluated cases.

Next, we create a function definition for the LHS of each equation in
$\mathcal{E}$, including all functions and base cases. The signatures of these
functions is decided as follows. A function call containing only variable
arguments is named as the function itself, and ones with constants in their
arguments are suffixed with a string that contains \texttt{'x'} at the $i$th
place if the $i$th argument is variable and the $i$th argument if that argument
is a constant. For example, $f(x_{1}, x_{2}, x_{3})$ is declared as \texttt{int
  f(int x1, int x2, int x3);} and $f(1, x_{2}, x_{3})$ is declared as
\texttt{int f\_1xx(int x2, int x3);} (the constant arguments are removed from
the signature).

The RHS of each equation in $\mathcal{E}$ is used to define the body of the
equation corresponding to the LHS of that equation. The function body (for a
function \texttt{func} corresponding to equation $e$) is formed as follows.

First, we check if the evaluation is already present in the cache. If so, then
we return the cache element. The cache accesses are done using the
\texttt{get\_elem} function (definition given in the example), which resizes the
cache if the accessed index is out of range.

Second, if the element is absent, then we decide if the arguments corresponding
to $e$ or one of the functions corresponding to the base cases, based on the
value of the arguments. If it corresponds to the base cases, then we directly
call the base case function and return its value. Else, we evaluate the value
using the RHS, store the evaluated value in the cache and return the evaluated
value. Note that in this step, we only call the base case function with one more
constant argument than \texttt{func}. For example, \texttt{f0(x, y)} would call
\texttt{f0\_0x(y)} if $x = 0$ and \texttt{f0\_x0(x)} if $y = 0$.

Third, to translate the RHS, we convert $\sum_{x=a}^{b} \expr{}$ to
\begin{lstlisting}[escapeinside={(*}{*)}]
([y,z,...](){
    int sum = 0;
    for(int x = a; x <= b; x++)
        sum += (*$\expr{}$*);
    return sum;
})()
\end{lstlisting}
where $y, z, \dots$ are the free variables present in $\expr{}$.

\section{Experiments}

Comparing \textsc{Crane} and \textsc{FastWFOMC} on a larger set of benchmarks is
challenging because there is no automated way to translate a formula in \FO{} or
\Ctwo{} into \UFO{} (or even check if such an encoding is possible).

\paragraph{Benchmarks (probably for supplementary material).}
\begin{itemize}
  \item Functions
        \begin{itemize}
          \item In \Ctwo: $\forall X \in \Delta\text{.
                }\exists^{=1} Y \in \Delta\text{. }p(X, Y)$
          \item In \UFO:
                \begin{gather*}
                  \forall X, Y \in \Delta\text{. } s(X) \lor \neg p(X, Y)\\
                  |p| = |\Delta|
                \end{gather*}
          \item In \FO:
                \begin{gather*}
                  \forall X \in \Delta\text{. }\exists Y \in \Delta\text{. } p(X, Y)\\
                  \forall X, Y, Z \in \Delta\text{. } p(X, Y) \land p(X, Z) \Rightarrow Y = Z
                \end{gather*}
        \end{itemize}
  \item Permutations
        \begin{itemize}
          \item In \Ctwo:
                \begin{gather*}
                  \forall X \in \Delta\text{. }\exists^{=1} Y \in \Delta\text{. }p(X, Y)\\
                  \forall Y \in \Delta\text{. }\exists^{=1} X \in \Delta\text{. }p(X, Y)
                \end{gather*}
          \item In \UFO:
                \begin{gather*}
                  \forall X, Y \in \Delta\text{. } r(X) \lor \neg p(X, Y)\\
                  \forall X, Y \in \Delta\text{. } s(X) \lor \neg p(Y, X)\\
                  |p| = |\Delta|
                \end{gather*}
                with weights $w^{-}(r) = w^{-}(s) = -1$
          \item In \FO:
                \begin{gather*}
                  \forall X \in \Delta\text{. }\exists Y \in \Delta\text{. } p(X, Y)\\
                  \forall Y \in \Delta\text{. }\exists X \in \Delta\text{. } p(X, Y)\\
                  \forall X, Y, Z \in \Delta\text{. } p(X, Y) \land p(X, Z) \Rightarrow Y = Z\\
                  \forall X, Y, Z \in \Delta\text{. } p(X, Y) \land p(Z, Y) \Rightarrow X = Z
                \end{gather*}
        \end{itemize}
\end{itemize}

\paragraph{Setup.}
\begin{itemize}
  \item The experiments were run on an AMD~Ryzen~7~5800H processor with
        \SI{16}{\gibi\byte} of memory and Arch Linux~6.8.2-arch2-1 operating
        system. \textsc{FastWFOMC} was run using Python~3.8.19 with
        Python-FLINT~0.5.0.
\end{itemize}

\begin{figure}
  \centering
  \input{plot}
  \caption{The runtime data of WFOMC algorithms on permutation- and
    function-counting problems on domains of sizes $1, 2, \dots, 35$. Note that
    the $y$ axis is on a logarithmic scale.}\label{fig:plot}
\end{figure}

\paragraph{Results.}
\begin{itemize}
  \item As shown in \cref{fig:plot}, the runtimes of all compilation-based
        algorithms remain practically constant in contrast to the rapidly
        increasing runtimes of \textsc{FastWFOMC}.
  \item Note that \textsc{Crane-BFS} is able to handle more instances than
        \textsc{ForcLift} (e.g., the permutation-counting problem in our
        experiments and other problems in my previous work).
  \item Although the search/compilation part is slower in \textsc{Crane} than in
        \textsc{ForcLift}, the difference is negligible.
  \item The runtimes of three out of four WFOMC algorithms appear constant
        because---for these counting problems and domain sizes---compilation
        time dominates inference time (recall that compilation time is
        independent of domain sizes). Indeed, the maximum inference time of both
        \textsc{Crane-BFS} and \textsc{Crane-Greedy} across these experiments is
        only \SI{4}{\milli\second}.
  \item The runtimes of \textsc{Crane} have lower variation than those of
        \textsc{ForcLift} because with \textsc{ForcLift} we compile the formula
        anew for each domain size whereas with \textsc{Crane} we compile it once
        and reuse the resulting C++ program for all domain sizes.
  \item As another point of comparison,---in at most
        \SI{41}{\second}---\textsc{Crane} scales up to domains of sizes \num{e4}
        and \num{3e5} in permutation- and function-counting problems,
        respectively (whereas \textsc{FastWFOMC} already takes longer with
        domains of sizes\dots)
\end{itemize}

\todo[inline,caption={}]{
  Some reproducibility requirements to keep in mind:
  \begin{itemize}
    \item A motivation is given for why the experiments are conducted on the
          selected datasets.
    \item All novel datasets introduced in this paper are included in a data
          appendix.
    \item All datasets drawn from the existing literature (potentially including
          authors’ own previously published work) are accompanied by appropriate
          citations. (mention the counting quantifier paper and my KR paper)
    \item All source code implementing new methods have comments detailing the
          implementation, with references to the paper where each step comes
          from.
    \item This paper formally describes evaluation metrics used and explains the
          motivation for choosing these metrics.
    \item This paper states the number of algorithm runs used to compute each
          reported result.
  \end{itemize}
}

\section{Conclusion}

\bibliographystyle{kr}
\bibliography{paper}

% TODO: for references, maybe fix the spelling of Kuzelka's name

% TODO: the report has some (long) examples of formulas being transformed into
% programs perhaps suitable for supplementary material


\end{document}

