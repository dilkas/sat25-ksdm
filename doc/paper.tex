\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{ijcai23}

\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[switch]{lineno}

\usepackage{listings}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{microtype}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{tikz}
\usepackage[backgroundcolor=lightgray]{todonotes}

% Comment out this line in the camera-ready submission
\linenumbers

\urlstyle{same}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem*{remark}{Remark}
\newtheorem{fact}{Fact}

% PDF Info Is REQUIRED.
% Please **do not** include Title and Author information
\pdfinfo{
/TemplateVersion (IJCAI.2023.0)
}

\lstset{breaklines=true}
\lstset{language=C++,
        basicstyle=\ttfamily,
        stringstyle=\color{red},
        commentstyle=\color{green},
        breaklines=true,
        showstringspaces=false}

\crefname{line}{line}{lines}
\crefalias{formula}{equation}
\crefname{formula}{Clause}{Clauses}
\creflabelformat{formula}{#2\textup{(#1)}#3}

\DeclareMathOperator{\Dom}{Dom}
\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator{\Preds}{Preds}
\DeclareMathOperator{\Vars}{Vars}
\DeclareMathOperator*{\argmin}{argmin}
\newcommand{\expr}{\mathtt{expr}}

\SetKwFunction{Crane}{Crane}
\SetKwFunction{Propagate}{Propagate}
\SetKwFunction{FindBaseCases}{FindBaseCases}

\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes}
\usetikzlibrary{fit}

\title{Towards Practical First-Order Model Counting}

% \author{
% First Author$^1$
% \and
% Second Author$^2$\and
% Third Author$^{2,3}$\And
% Fourth Author$^4$
% \affiliations
% $^1$First Affiliation\\
% $^2$Second Affiliation\\
% $^3$Third Affiliation\\
% $^4$Fourth Affiliation
% \emails
% \{first, second\}@example.com,
% third@other.example.com,
% fourth@example.com
% }

\begin{document}

\maketitle

% <= 200 words
\begin{abstract}
\end{abstract}

\section{Introduction}

\todo[inline,caption={}]{
  \begin{itemize}
    \item mention/describe the arithmetic simplification code
    \item (in Fig. 1) Crane2 doesn't use Crane, it uses itself
    \item describe which compilation rules are currently greedy or non-greedy
    \item my agenda has a plan for proving completeness for $\mathbf{C}^{2}$
  \end{itemize}
}

\paragraph{Changes to the compilation process.}
\begin{itemize}
  \item We make the FCGs satisfy the following property. For every domain
        $\Delta$, for every directed path $P$ without Ref nodes, the number of
        atom counting or (generalised) domain recursion or independent partial
        grounding operations on $\Delta$ on $P$ is at most one.
  \item when checking whether recursion is possible between a source and a
        target formula, the target formula (maybe the source formula as well?)
        must not include a domain as well as its subdomain. This might be
        equivalent to the formula being `unshattered'. Such formulas could be
        seen as transitory, and allowing such recursive calls leads to FCGs that
        I cannot make sense of.
  \item Implemented an if-then-else arithmetic operation as the interpretation
        of the new domain recursion node (i.e., there is one branch for when the
        domain is empty and another branch for any other domain size).
  \item \Cref{sec:main,sec:identifying} might also be outdated: there is
        probably no need to search for base cases given the new version of
        domain recursion.
\end{itemize}

\paragraph{Proof of correctness.}
\begin{enumerate}
  \item Define what it means for a formula to be \emph{consistent}.
        \begin{itemize}
          \item The formula (including the mapping of constants to their
                domains) does not mention a domain together with its subdomain
                (i.e., all mentioned domains are pairwise disjoint).
                Specifically, we can't have a subdomain together with its parent
                domain or a subdomain together with a constant that belongs to
                its parent domain.
          \item The target of \texttt{Ref} must also be a consistent formula.
          \item The initial formula is consistent by definition.
        \end{itemize}
  \item Aim to show that Crane works correctly on all consistent formulas.
  \item Prove that, whenever some compilation rule makes the formula $\phi$
        inconsistent, greedy compilation rules will make $\phi$ consistent again
        before $\phi$ encounters non-greedy compilation rules that depend on
        $\phi$ being consistent.
        \begin{itemize}
          \item In particular, prove that shattering and unit propagation will
                always eliminate the parent domain of the domains introduced by
                atom counting.
          \item Constraint removal only applies when it can eliminate the parent
                domain entirely.
          \item Prove this for a particular assumption about which compilation
                rules are set to be greedy. For the greedy algorithm, although
                all rules are applied in a greedy manner, we still assume that
                greedy rules will be applied before non-greedy rules.
        \end{itemize}
  \item In particular, independent partial groundings and atom counting are the
        two classical rules that require the formula to be shattered.
  \end{enumerate}

\begin{figure*}[t]
  \centering
  \begin{tikzpicture}
    \node at (0, 0) (formula) {$\phi$};
    \node[draw,rounded rectangle] at (3, 0) (alg1) {\Cref{alg:main}};
    \node[draw,rounded rectangle] at (6, 0) (simplification) {Simplification};
    \node[draw,rounded rectangle] at (9, 0) (compilation) {Compilation};

    \node[draw,rounded rectangle,dashed] at (12, 0) (cpp) {C++ code};
    \node at (12, -1) (sizes) {Domain sizes};

    \node at (15, 0) (count) {Model count};

    \node[draw,rounded rectangle] at (3, -2) (alg2) {\Cref{alg1}};
    \node[draw,rounded rectangle,left = 0.1cm of alg2] (crane) {\textsc{Crane}};
    \node[draw,rounded rectangle,right = 0.1cm of alg2] (alg3) {\Cref{alg2}};

    \node[draw,fit={(alg1) (simplification) (compilation) (crane) (alg2) (alg3)},inner ysep=7pt,yshift=5pt] {};
    \node at (1.1, 0.5) {\textsc{Crane2}};

    \draw[->] (formula) -- (alg1);
    \draw[->] (alg1) -- node[above] {$E$} (simplification);
    \draw[->] (simplification) -- node[above] {$E'$} (compilation);
    \draw[->] (compilation) -- (cpp);
    \draw[->] (sizes) -- (cpp);
    \draw[->] (cpp) -- (count);

    \draw[->,dashed] (alg1) -- node[midway,left] {uses} (crane);
    \draw[->,dashed] (alg1) -- node[midway] {uses} (alg2);
    \draw[->,dashed] (alg1) -- node[midway,right] {uses} (alg3);
  \end{tikzpicture}
  \caption{Using \textsc{Crane2} to compute the model count of formula $\phi$.\
    The formula is compiled into a set of equations $E$, which are then
    algebraically simplified and compiled to a C++ program. This program can
    then be run with different command line arguments to compute the model count
    of $\phi$ for various domain sizes.}
\end{figure*}

The evaluation of base cases is done by simplifying the clauses and then using
\textsc{Crane} to find the base cases. First, while traversing the graph to find
the equations, we store two maps: $\mathcal{F}$ (which stores the mapping from
the function names to the formulae, whose model count they represent) and
$\mathcal{D}$ (which stores the mapping from the variable names to the domains
whose sizes they represent). Then, a particular domain is selected (using the
algorithm described in previous reports), and the clauses are simplified. Then,
\textsc{Crane} is called on those clauses to evaluate the base cases. After
that, we change the function names and variable to make it consistent with the
previous domain to variable mapping, and append these base cases to the set of
equations.

\paragraph{Contributions.}
\begin{itemize}
  \item \Cref{sec:identifying}
  \item \Cref{sec:simplifying}
  \item Converting the recursive equations into a C++ program, which can then be
        compiled and executed to obtain numerical values (see \cref{sec:cpp}).
  \item Support for infinite precision integers using the GNU Multiple Precision
        Arithmetic Library.
  \item A new set of benchmarks.
  \item The experiments for Crane and ForcLift are (going to be) more
        comprehensive than any other experimental study performed on (W)FOMC
        algorithms.
  \item Some experiments vs FastWFOMC
  \item A proof of correctness
  \item A proof of completeness
\end{itemize}

\todo[inline]{references to my previous paper and some of the \textsc{ForcLift}
  and \textsc{FastWFOMC} papers that contain experimental results}

\Cref{sec:identifying,sec:cpp} deal with algebraic constructs whereas
\cref{sec:simplifying} deals with logic.

\section{Preliminaries}

\subsection{Algebra}

\paragraph{Notation.}
We write $\expr{}$ for an arbitrary algebraic expression. For any signature or
clause $C$, argument or variable $x$, and number or constant $t$, we shall write
$C[t / x]$ for the result of substituting $t$ for all occurrences of $x$ in $C$.

\todo[inline,caption={}]{
  \begin{itemize}
    \item check if I'm still using this notation in all these cases
    \item explain how this works for function calls too
  \end{itemize}
}

\begin{definition}
  A \emph{function call} is a term of the form
  $f(x_{1} - c_{1}, \dots, x_{n} - c_{n})$ (written $f(\mathbf{x} - \mathbf{c})$
  for short), where $f$ is an $n$-ary function, each $x_{i}$ is a variable, and
  each $c_{i}$ is a non-negative constant.
\end{definition}
\todo[inline]{do I ever use this term for the case when some of the variables
  don't exist?}

\begin{definition}
  A \emph{signature} is a term of the form $f(x_{1}, \dots, x_{n})$ (written
  $f(\mathbf{x})$ for short), where $f$ is an $n$-ary function, and each $x_{i}$
  is a variable. The signature of a function call $f(\mathbf{x} - \mathbf{c})$
  is $f(\mathbf{x})$. For example, the signature of $f(x - 1, y - 2)$ is
  $f(x, y)$.
\end{definition}

\begin{definition}
  An \emph{equation} is always of the form $f(\mathbf{x}) = \expr{}$, where
  $f(\mathbf{x})$ is a signature, and $\expr{}$ is an algebraic expression.
  Henceforth, we call $f(\mathbf{x})$ and $\expr{}$ the left-hand side (LHS) and
  the right-hand side (RHS) of the equation, respectively.
\end{definition}
\todo[inline,caption={}]{
  give some examples of formulas that:
  \begin{itemize}
    \item introduce new variables,
    \item call the function itself,
    \item call some other function, and
    \item is more nested than just a sum.
  \end{itemize}
}

\begin{definition}
  A \emph{base case} is a function call where all arguments are either variables
  or constants (i.e., there is no subtraction within any argument), and there is
  at least one constant.
\end{definition}

\subsection{Logic}

\todo[inline,caption={}]{
  \begin{itemize}
    \item What notation am I using for FOL? Colon after every quantifier?
    \item (Similar to CNF, maybe QBF). Incomplete. Need (W)FOMC semantics. What
          is an interpretation? What is a model?
  \end{itemize}
}

A \emph{formula} is a set of clauses. A \emph{clause} is of the form
$\forall x_{1} \in \Delta_{1}\forall x_{2} \in \Delta_{2}\dots\forall x_{n} \in \Delta_{n} \phi(x_{1}, x_{2}, \dots, x_{n})$,
where $\phi$ is a disjunction of literals that only contain variables
$x_{1}, \dots, x_{n}$ (and any constants). A \emph{literal} is either an atom or
its negation. An \emph{atom} is of the form $P(t_{1}, \dots, t_{m})$, where $P$
is a predicate, and $t_{1}, \dots, t_{m}$ are terms. A \emph{term} is either a
variable or a constant.

\todo[inline]{explain set-based notation for a clause (iterating over all
  literals)}

For any clause $C$, let $\Preds(C)$ denote the set of predicates in $C$. For any
clause or literal $l$, let $\Vars(l)$ denote the set of variables in $l$.

For any (bound) variable $v$, let $\Dom(v)$ denote the domain over which $v$ is
quantified. For a literal $l$,
$\Doms(l) \coloneqq \{\, \Dom(v) \mid v \in \Vars(l) \,\}$. Similarly, for any
clause $C$, let $\Doms(C) = \{\, \Dom(v) \mid v \in \Vars(C) \,\}$.

\section{Smoothing}

Goal of smoothing: whenever rules such as unit propagation or
inclusion-exclusion (maybe just these two?) eliminate the consideration of some
ground atoms, smoothing nodes should be inserted `at the same level' so that
these ground atoms are still considered when counting. Note that conjunction
nodes are irrelevant here because multiplication is associative. `At the same
level' means that, e.g., if some ground atoms were eliminated from consideration
before/after performing independent partial grounding, then the smoothing node
should also appear before/after the independent partial grounding node.

\todo[inline]{ Can I prove that the additions to smoothing outlined in the rest
  of this section `do the right thing'? }

\subsection{Stage 1: Propagating Unit Clauses `Upwards'}

\begin{description}
  \item[\texttt{Ref}:] during smoothing, when unit clauses (a.k.a.\ variables)
        are propagated in the opposite direction of the FCG arcs (i.e.,
        `upwards'), when visiting a \texttt{Ref} node, these clauses are
        translated using the domain map of the \texttt{Ref} node. For example,
        if the domain map include $\Delta \mapsto \Delta'$, and the unit clause
        mentions $\Delta$, then replace it by $\Delta'$.
  \item[Constraint removal:] do reverse constraint removal. Assuming that
        domain $\Delta$ with constraints $X \ne c$ (for some constant
        $c \in \Delta$) were replaced with domain $\Delta'$, replace each
        $\forall X \in \Delta'\text{. }\phi(X)$ with
        $\forall X \in \Delta\text{. }X \ne c \Rightarrow \phi(X)$.
  \item[Domain recursion:] nothing special needs to be done (just propagate the
        union of the two sets of unit clauses upwards), assuming that $P(c)$ and
        $\forall X \in \Delta\text{. }X \ne c \Rightarrow P(X)$ are
        automatically combined into $\forall X \in \Delta\text{. }P(X)$.
\end{description}

\subsection{Stage 2: Adding Smoothing Nodes}

\begin{description}
  \item[\texttt{Ref}:] nothing.
  \item[Constraint removal:] nothing.
  \item[Domain recursion:] Smoothing for domain recursion now works the same way
        as smoothing for disjunction: both sides must have the same atoms EXCEPT
        the `base case' side need not include unit clauses that mention the
        constant introduced by this domain recursion node or its domain (since
        this branch assumes that this domain is empty). NOTE: As a consequence,
        almost all of \cref{sec:simplifying} is now outdated because smoothing
        makes the ``tautology insertion'' unnecessary.
\end{description}

\section{The Main Algorithm: Finding the Definitions of the Base
  Cases}\label{sec:main}

\begin{algorithm}[t]
  \caption{Finding the definitions of the base cases}\label{alg:main}
  \KwIn{formula $\phi$}
  \KwOut{a set $E$ of equations that define $B$}
  $(E, \mathcal{F}, \mathcal{D}) \gets \Crane{$\phi$}$\;
  \ForEach{base case $f(\mathbf{x}) \in \FindBaseCases{$E$}$}{
    $\psi \gets \mathcal{F}(f)$\;
    \ForEach{$i$ such that $x_{i}$ is a constant}{
      $\psi \gets \Propagate{$\psi$, $\mathcal{D}(f, i)$, $x_i$}$\;
    }
    $(E', \text{\textunderscore}, \text{\textunderscore}) \gets \Crane{$\psi$}$\;
    $E \gets E \cup E'$\;
  }
\end{algorithm}

See \cref{alg:main}

\todo[inline,caption={}]{
  \begin{itemize}
    \item extend it to work with base cases that are themselves recursive
    \item what does it mean for a set of equations to define a set of base cases?
    \item for base cases, we will also use the $f(\mathbf{x})$ notation
  \end{itemize}
}

\section{Identifying a Sufficient Set of Base Cases}\label{sec:identifying}

\begin{algorithm}[t]
  \caption{\protect\FindBaseCases{$E$}}\label{alg1}
  \KwIn{set $E$ of equations}
  \KwOut{set $B$ of base cases}

  $B \gets \emptyset$\;
  \ForEach{equation $(f(\mathbf{x}) = \expr{}) \in E$}{
    \ForEach{function call $f(\mathbf{x} - \mathbf{c}) \in \expr{}$}{\label{line:functioncall}
      \ForEach{$c_{i} \in \mathbf{c}$}{
        \For{$n \gets 0$ \KwTo $c_{i} - 1$}{\label{line:lim}
          $B \gets B \cup \{\, f(\mathbf{x})[x_{i}/n] \,\}$\;\label{line:insert}
        }
      }
    }
  }
\end{algorithm}

We know that if, say, on the RHS of all equations, the domain size appears as
$m - c_1, m - c_2, \dots, m - c_k$, then finding $f(0, x_1, x_2, \dots)$,
$f(1, x_1, x_2, \dots)$, $\dots f(m_0, x_1, x_2, \dots)$ for every function $f$,
where $m_0 = \max(c_1, c_2, \dots c_k) - 1$ forms a sufficient set of base
cases. Hence, in order to do the same efficiently, we can take that domain for
which $m_0$ is the minimum, i.e. $\argmin(\max(c_1, c_2, \dots c_k))$. Ideally,
we should calculate the base cases by finding the base cases up to
$\max(c_{1}, c_{2}, \dots) - 1$. However, currently only empty and singleton
domains are supported.

\todo[inline,caption={}]{
  \begin{itemize}
    \item NOTE: \cref{line:functioncall} iterates over all function calls in the
          algebraic expression
    \item remove the `dependencies' data structure from the description
  \end{itemize}
}

The following steps were followed while finding the base cases:

First, expand the summations in each equation. Here we expand the summations of
the form: $\sum_{x=0}^{x_{1}} \expr{} \cdot [a \le x < b]$ or similar
inequalities where $x$ is bounded by constants and $a$ and $b$ are constants, by
substituting the value of $x$ from $a$ to $b-1$. For example, we replace
$\sum_{x=0}^{x_1} \binom{x_{1}}{x} f(x_1 - x) \cdot [0 \le x < 2]$ by
$\binom{x_{1}}{0} f(x_1) + \binom{x_{1}}{1} f(x_1-1)$.

Now, we find a domain that has only terms of the form $x-1$ appearing on the RHS
of the dependencies. The base cases are then calculated by setting this domain
size to zero. For the above example, $n$ is the selected domain, and not $m$
since there are $m-2$ and $m-3$ terms appearing in the arguments.

The algorithm is described as \cref{alg1}.

\todo[inline,caption={}]{
  add an example where \cref{alg1} runs on either
  \begin{align*}
    f_{0}(m, n) &= f_{1}(m-1, n) + f_{2}(m, n-1)\\
    f_{1}(m, n) &= f_{1}(m-1, n-1) \times f_{2}(m-2, n-1)\\
    f_{2}(m, n) &= 2 \times f_{1}(m-3, n-1)
  \end{align*}
  or
  \begin{align*}
    f(m, n) &= g(m-1, n) + f(m-2, n-1)\\
    g(m, n) &= f(m-1, n-2) + g(m-1, n-1).
  \end{align*}
}

\begin{itemize}
  \item \cref{line:lim}: the limit is 2 for the arg $(x-3)$.
  \item \cref{line:insert} for $f(\mathbf{x}) = f(y, z)$, $x_{i} = y$, and
        $n = 0$, add $f(y, z)[y/0] = f(0, z)$ to $B$.
\end{itemize}

\todo[inline]{I changed the algorithm. Update the description.}

\begin{theorem}
  Under the following assumptions, \cref{alg1} is guaranteed to return a
  sufficient set of base cases:
  \begin{itemize}
    \item there is no mutual recursion (i.e., cyclic dependencies between
          functions);
    \item each function $f$ has exactly one equation with $f$ on the LHS;
    \item in the recursive definition of function $f(x_{1},\dots,x_{n})$, the
          $i$-th argument of each call to $f$ on the RHS is of the form
          $x_{i} - c_{i}$, where:
          \begin{itemize}
            \item $c_{i} \ge 0$ for all $i$, and
            \item $c_{i} > 0$ for at least one $i$.
          \end{itemize}
  \end{itemize}
\end{theorem}

\begin{example}
  For an equation $f(m, n) = 2 \times f(m-1, n)$, \cref{alg1} returns $f(0, n)$.
\end{example}

NOTE: function calls such as $f(n-m)$ and $f(n-m-1)$ are ignored.

\section{Propagating Domain Size Assumptions}\label{sec:simplifying}

\subsection{Motivation: Why Tautologies Are Needed and Simply Removing The
  Clauses Does Not Work}

\begin{fact}
  Assuming that domain $\Delta$ is empty, any clause that contains
  `$\forall x \in \Delta$' (for any variable $x$) is vacuously satisfied by all
  interpretations.
\end{fact}

For example, consider the formula
\begin{align}
  \forall x \in \Delta \forall y, z \in \Gamma &: P(x) \lor Q(y, z)\label[formula]{eq:example1}\\
  \forall y, z \in \Gamma' &: Q(y, z)\label[formula]{eq:example2}
\end{align}
and assume that $\Gamma' \subseteq \Gamma$. In this case, if we set $|\Delta|$
to zero and remove clauses with variables quantified over $\Delta$, we get
\begin{equation}\label[formula]{eq:simplified}
  \forall y, z \in \Gamma' : Q(y, z),
\end{equation}
but the model count of \cref{eq:simplified} is one. However, the actual model
count should be $2^{|\Gamma|^2 - |\Gamma'|^2}$. That is, $Q$ as a relation is a
subset of $\Gamma \times \Gamma$. While \cref{eq:example1} becomes vacuously
true, \cref{eq:example2} fixes the value of $Q$ over
$\Gamma' \times \Gamma' \subseteq \Gamma \times \Gamma$. Hence, the number of
different values that $Q$ can take is
$|(\Gamma \times \Gamma) \setminus (\Gamma' \times \Gamma')| = |\Gamma|^{2} - |\Gamma'|^{2}$.

We address this issue by converting clauses with universal quantifiers over the
empty domain to tautologies, hence retaining all the predicates that have no
argument assigned to the empty domain. For example, we would convert
\cref{eq:example1,eq:example2} to
\begin{align*}
  \forall y, z \in \Gamma &: Q(y, z) \lor \neg Q(y, z) \\
  \forall y, z \in \Gamma' &: Q(y, z).
\end{align*}
The model count returned by this will also consider the truth value of $Q$ over
$y \in \Gamma \setminus \Gamma'$ or $z \in \Gamma \setminus \Gamma'$.

\subsection{The Solution}

\begin{algorithm}[t]
  \caption{\protect\Propagate{$\phi$, $\Delta$, $n$}}\label{alg2}
  \KwIn{formula $\phi$, domain $\Delta$, domain size $n \in \{\, 0, 1 \,\}$}
  \KwOut{formula $\phi'$}
  $\phi' \gets \emptyset$\;
  \uIf{$n = 0$}{
    \ForEach{clause $C \in \phi$}{
      \lIf{$\Delta \not\in \Doms(C)$}{$\phi' \gets \phi' \cup \{\, C \,\}$}
      $C' \gets \{\, l \in C \mid \Delta \not\in \Doms(l) \,\}$\;
      \If{$\Delta \in \Doms(C)$ {\bf and} $C' \ne \emptyset$}{
        $l \gets \text{an arbitrary literal in } C'$\;
        $\phi' \gets \phi' \cup \{\, C' \cup \{\, \neg l \,\} \,\} $\;
      }% TODO: find the source code and check: 1) what we're doing with unit clauses, 2) whether we just randomly pick any literal to negate
    }
  }
  \Else{
    $c \gets$ a new constant symbol\;
    \ForEach{clause $C \in \phi$}{
      $C' \gets C$\;
      \ForEach{$v \in \Vars(C)$ with $\Dom(v) = \Delta$}{
        $C' \gets C'[c / v]$\;
      }
      $\phi' \gets \phi' \cup \{\, C' \,\}$\;
    }
  }
\end{algorithm}

\todo[inline]{it would be easy to extend the second part to an arbitrary constant}

We use \cref{alg2} to find the transformed formula corresponding to each base
case obtained using \cref{alg1} and call \textsc{Crane} on the formula to obtain
the required base cases.

\begin{itemize}
  \item Similar to generalised domain recursion (what's the difference?).
  \item Clauses where all literals have variables quantified over the empty
        domain are still removed.
  \item $C'$ is guaranteed to be non-empty.
\end{itemize}

\section{Generating C++ Code}\label{sec:cpp}

\todo[inline]{the report has some (long) examples of formulas being transformed
  into programs perhaps suitable for supplementary material}

The target is to generate C++ code that can evaluate numerical values of the
model counts based on the equations generated by \textsc{Crane}. We achieve this
by parsing the equations generated by \textsc{Crane}, simplifying them, and then
generating C++ code. This approach can be done in linear time in the length of
the formula using
the
\href{https://en.wikipedia.org/wiki/Shunting_yard_algorithm#:~:text=In%20computer%20science%2C%20the%20shunting,abstract%20syntax%20tree%20(AST).}{Shunting
  Yard Algorithm}.

The translation of a set $E$ of equations into a C++ program works as follows.

First, we create a cache for each function in $E$. This is implemented as a
multi-dimensional vector containing objects of \texttt{class cache\_elem}
defined as shown in the example code. The default initialization of this object
is to $-1$ which is useful for recognizing unevaluated cases.

Next, we create a function definition for the LHS of each equation in $E$,
including all functions and base cases. The signatures of these functions is
decided as follows. A function call containing only variable arguments is named
as the function itself, and ones with constants in their arguments are suffixed
with a string that contains \texttt{'x'} at the $i$th place if the $i$th
argument is variable and the $i$th argument if that argument is a constant. For
example, $f(x_{1}, x_{2}, x_{3})$ is declared as \texttt{int f(int x1, int x2,
  int x3);} and $f(1, x_{2}, x_{3})$ is declared as \texttt{int f\_1xx(int x2,
  int x3);} (the constant arguments are removed from the signature).

The RHS of each equation in $E$ is used to define the body of the equation
corresponding to the LHS of that equation. The function body (for a function
\texttt{func} corresponding to equation $e$) is formed as follows.

First, we check if the evaluation is already present in the cache. If so, then
we return the cache element. The cache accesses are done using the
\texttt{get\_elem} function (definition given in the example), which resizes the
cache if the accessed index is out of range.

Second, if the element is absent, then we decide if the arguments corresponding
to $e$ or one of the functions corresponding to the base cases, based on the
value of the arguments. If it corresponds to the base cases, then we directly
call the base case function and return its value. Else, we evaluate the value
using the RHS, store the evaluated value in the cache and return the evaluated
value. Note that in this step, we only call the base case function with one more
constant argument than \texttt{func}. For example, \texttt{f0(x, y)} would call
\texttt{f0\_0x(y)} if $x = 0$ and \texttt{f0\_x0(x)} if $y = 0$.

Third, to translate the RHS, we convert $\sum_{x=a}^{b} \expr{}$ to
\begin{lstlisting}[escapeinside={(*}{*)}]
([y,z,...](){
    int sum = 0;
    for(int x = a; x <= b; x++)
        sum += (*$\expr{}$*);
    return sum;
})()
\end{lstlisting}
where $y, z, \dots$ are the free variables present in $\expr{}$.

\section{Experiments}

\paragraph{Remarks on comparing the model counts of the formulas with their
  corresponding OEIS sequences.}
Disregarding differences where the OEIS sequence starts with one or two numbers
that are not included in model counts (which is somewhat justified since we
start with domains of size one rather than zero), two differences remain:
\begin{itemize}
  \item on A62971, the OEIS sequence starts as $1, 2, 16,\dots$, but the model
        counts start as $1, 16,\dots$ (with the rest exactly the same);
  \item similarly, on A62971, the OEIS sequence starts as $32, 290,\dots$, but
        the model counts start as $2, 32, 290,\dots$ (with the rest exactly the
        same).
\end{itemize}

\section{Conclusion}

\bibliographystyle{named}
\bibliography{paper}

\end{document}

