\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

\usepackage{kr}

\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\urlstyle{same}

\usepackage[backgroundcolor=lightgray]{todonotes}
\usepackage{listings}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{microtype}
\usepackage{mathtools}
\usepackage{forest}
\usepackage{siunitx}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage[inline]{enumitem}

\usetikzlibrary{arrows.meta}

\newtheorem{theorem}{Theorem}
\newtheorem{fact}{Fact}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

\pdfinfo{
/TemplateVersion (KR.2022.0, KR.2023.0, KR.2024.0)
}

\forestset{
  sn edges/.style={for tree={edge={-Latex}}}
}

\lstset{breaklines=true}
\lstset{language=C++,
        basicstyle=\ttfamily,
        stringstyle=\color{red},
        commentstyle=\color{green},
        breaklines=true,
        showstringspaces=false}

\crefname{line}{line}{lines}

\crefalias{enumi}{type}
\crefname{type}{Type}{Types}
\creflabelformat{type}{#2\textup{#1}#3}

\crefalias{clause}{equation}
\crefname{clause}{Clause}{Clauses}
\creflabelformat{clause}{#2\textup{(#1)}#3}

\crefalias{formula}{equation}
\crefname{formula}{Formula}{Formulas}
\creflabelformat{formula}{#2\textup{(#1)}#3}

\DeclareMathOperator{\CR}{CR}
\DeclareMathOperator{\DR}{DR}
\DeclareMathOperator{\Reff}{Ref}

\DeclareMathOperator{\Doms}{Doms}
\DeclareMathOperator*{\argmin}{argmin} % TODO: soon to be removed

\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\newcommand{\expr}{\mathtt{expr}}
\newcommand{\Ctwo}{$\mathsf{C}^{2}$}
\newcommand{\FO}{$\mathsf{FO}$}
\newcommand{\UFO}{$\mathsf{UFO}^{2} + \mathsf{EQ}$}

\newcommand{\Cranetwo}{\textsc{Crane2}}
\newcommand{\Cranebfs}{\textsc{Crane2-BFS}}
\newcommand{\Cranegreedy}{\textsc{Crane2-Greedy}}

\SetKwFunction{CompileWithBaseCases}{CompileWithBaseCases}
\SetKwFunction{Crane}{Compile}
\SetKwFunction{Propagate}{Propagate}
\SetKwFunction{FindBaseCases}{FindBaseCases}
\SetKwFunction{Simplify}{Simplify}

\title{Towards Practical First-Order Model Counting}

\author{%
  Ananth K. Kidambi$^1$\footnote{The first and second authors contributed equally and were affiliated with the National University of Singapore during the completion of this work.}\and
Guramrit Singh$^1$\and
Paulius Dilkas$^2$\and
Kuldeep S. Meel$^3$ \\
\affiliations
$^1$Indian Institute of Technology Bombay, Mumbai, India\\
$^2$National University of Singapore, Singapore, Singapore\\
$^3$University of Toronto, Toronto, Canada\\
\emails
\{210051002, 210050061\}@iitb.ac.in,
paulius.dilkas@nus.edu.sg,
meel@cs.toronto.edu
}

\begin{document}

\maketitle

\begin{abstract}
  TODO: at most 200 words
\end{abstract}

\section{Introduction (TODO)}

\todo[inline,caption={}]{
  \begin{itemize}
    \item 9 pages including appendices but not acknowledgements
    \item Add some papers mentioned in:
          \begin{itemize}
            \item very recent work
            \item my previous paper, including:
                  \begin{itemize}
                    \item other liftable fragments
                    \item some more theory papers, e.g., LICS 2018
                  \end{itemize}
          \end{itemize}
  \end{itemize}
}

\paragraph{Papers To Cite}
\begin{itemize}
  \item overviews
        \begin{itemize}
          \item lifted probabilistic inference~\cite{DBLP:conf/ecai/Kersting12}
          \item recent overview paper~\cite{DBLP:conf/ijcai/Kuzelka23}
        \end{itemize}
  \item Alternative definition~\cite{DBLP:journals/cacm/GogateD16}
  \item relevant theoretical work~\cite{DBLP:conf/aaai/MalhotraS22}
  \item original domain recursion~\cite{DBLP:conf/nips/Broeck11}
  \item algorithms
        \begin{itemize}
          \item \textsc{ForcLift}~\cite{DBLP:conf/ijcai/BroeckTMDR11}
          \item \textsc{Crane}~\cite{DBLP:conf/kr/DilkasB23}
          \item \textsc{FastWFOMC}~\cite{DBLP:conf/uai/BremenK21}
          \item \textsc{L2C}~\cite{DBLP:conf/kr/KazemiP16} (similarly to us
                compiles to C++ code, but (probably) doesn't work on as many
                formulas)
          \item approximate~\cite{DBLP:conf/ijcai/BremenK20}
          \item for Markov logic networks~\cite{DBLP:journals/ml/RichardsonD06}
                \begin{itemize}
                  \item \textsc{Magician}~\cite{DBLP:conf/aaai/VenugopalSG15}
                  \item \textsc{Tuffy}~\cite{DBLP:journals/pvldb/NiuRDS11}
                  \item \textsc{Alchemy}~\cite{DBLP:journals/cacm/GogateD16}
                        (same as the alternative definition)
                \end{itemize}
        \end{itemize}
  \item complexity
        \begin{itemize}
          \item liftability~\cite{DBLP:conf/starai/JaegerB12}
          \item hardness for three variables~\cite{DBLP:conf/pods/BeameBGS15}
          \item liftable fragments
                \begin{itemize}
                  \item \Ctwo~\cite{DBLP:journals/jair/Kuzelka21}
                  \item tree axioms~\cite{DBLP:journals/ai/BremenK23}
                  \item linear order axioms~\cite{DBLP:conf/aaai/TothK23}
                  \item some liftable fragments~\cite{DBLP:conf/nips/KazemiKBP16}
                \end{itemize}
        \end{itemize}
  \item applications
        \begin{itemize}
          \item extensions to
                sampling~\cite{DBLP:conf/aaai/WangB0K22,DBLP:conf/lics/WangP0K23}
          \item discovery of combinatorial
                sequences~\cite{DBLP:conf/ijcai/SvatosJT0K23}
          \item conjecturing recurrence
                relations~\cite{DBLP:conf/ilp/BarvinekB0ZK21}
          \item probabilistic logic
                programming~\cite{DBLP:journals/ijar/RiguzziBZCL17} (WFOMC was
                shown to be supreme)
          \item probabilistic databases~\cite{DBLP:journals/debu/GribkoffSB14}
        \end{itemize}
  \item lifted inference elsewhere
        \begin{itemize}
          \item constraint satisfaction~\cite{DBLP:journals/jair/TotisDRK23}
          \item answer set programming~\cite{DBLP:journals/ijar/AzzoliniR23}
        \end{itemize}
\end{itemize}

\begin{figure*}[t]
  \centering
  \begin{tikzpicture}
    \node at (-1, 0) (formula) {$\phi$};
    \node[draw,rounded rectangle] at (3, 0) (compilewithbasecases) {\CompileWithBaseCases};
    \node[draw,rounded rectangle] at (9, 0) (compilation) {Compile to C++};

    \node[draw,rounded rectangle,dashed] at (12, 0) (cpp) {C++ code};
    \node at (12, -1) (sizes) {Domain sizes};

    \node at (15, 0) (count) {Model count};

    \node[draw,rounded rectangle] at (3, -2) (findbasecases) {\FindBaseCases};
    \node[draw,rounded rectangle,left = 0.1cm of findbasecases] (crane) {\Crane};
    \node[draw,rounded rectangle,right = 0.1cm of findbasecases] (propagate) {\Propagate};
    \node[draw,rounded rectangle,right = 0.1cm of propagate] (simplify) {\Simplify};

    \node[draw,fit={(compilewithbasecases) (compilation) (crane) (findbasecases) (propagate)},inner ysep=7pt,yshift=5pt] {};
    \node at (0.2, 0.5) {\Cranetwo};

    \draw[-Latex] (formula) -- (compilewithbasecases);
    \draw[-Latex] (compilewithbasecases) -- node[above] {$\mathcal{E}$} (compilation);
    \draw[-Latex] (compilation) -- (cpp);
    \draw[-Latex] (sizes) -- (cpp);
    \draw[-Latex] (cpp) -- (count);

    \draw[-Latex,dashed] (compilewithbasecases) -- node[midway,left] {uses} (crane);
    \draw[-Latex,dashed] (compilewithbasecases) -- node[midway,left] {uses} (findbasecases);
    \draw[-Latex,dashed] (compilewithbasecases) -- node[midway,left] {uses} (propagate);
    \draw[-Latex,dashed] (compilewithbasecases) -- node[midway,right] {uses} (simplify);
  \end{tikzpicture}
  \caption[]{The outline of using \Cranetwo{} to compute the model count of a
    formula $\phi$. The formula is compiled into a set of equations
    $\mathcal{E}$ that are then compiled to a C++ program. This program can then
    be run with different command line arguments to compute the model count of
    $\phi$ for various domain sizes. \CompileWithBaseCases makes use
    of: \begin{enumerate*}[label=(\roman*)]
      \item the knowledge compilation algorithm of \textsc{Crane} (denoted by \Crane),
      \item a procedure for identifying a sufficient set of base cases (denoted by \FindBaseCases),
      \item a procedure for constructing a formula that corresponds to a given base case (denoted by \Propagate), and
      \item algebraic simplification techniques (denoted by \Simplify).
    \end{enumerate*}
  }\label{fig:overview}
\end{figure*}

\todo[inline,caption={}]{
  \begin{itemize}
    \item By pointing to the outline in \cref{fig:overview}, make forward
          references to the sections of the paper.
    \item Somewhere: mention that we're primarily concerned with computing
          unweighted model counts, but everything trivially extends to the
          weighted setting as well.
    \item Introduce greedy search and breadth-first search (BFS), together with
          \Cranegreedy{} and \Cranebfs{}. The knowledge compilation part of both
          \textsc{Crane} and \Cranetwo{} can be executed using either greedy
          (similar to \textsc{ForcLift}) or breadth-first search. We use both in
          our experiments, denoting them as \Cranegreedy{} and \Cranebfs{},
          respectively.
    \item Introduce the WFOMC acronym.
    \item Introduce first-order knowledge compilation as a class of WFOMC
          algorithms, defining/mentioning compilation rules, FCG, etc.
  \end{itemize}
}

\paragraph{Contributions}
\begin{itemize}
  \item Completing the definitions of recursive functions by:
  \begin{itemize}
    \item identifying a sufficient set of base cases (\cref{sec:identifying})
    \item constructing formulas that correspond to these base cases
          (\cref{sec:simplifying})
    \item and recursing on these subproblems
  \end{itemize}
  \item Compiling these function definitions into a C++ program that can be
        executed independently for any domain size values \cref{sec:cpp}
        \begin{itemize}
          \item including support for infinite precision arithmetic via GNU
                Multiple Precision Arithmetic Library
        \end{itemize}
  \item Experiments comparing \Cranetwo{} with the main alternative approach
        demonstrate the ability of \Cranetwo{} to scale to domain sizes\dots
\end{itemize}

\Cref{sec:identifying,sec:cpp} deal with algebraic constructs whereas
\cref{sec:simplifying} deals with logic.

\section{Preliminaries (TODO)}

\Cref{sec:logic} introduces the fundamental ideas of first-order logic and
WFOMC, and discusses the different logics used in the latter.\@
\Cref{sec:algebra} introduces the terminology we use to describe the output of
the original \textsc{Crane} algorithm~\cite{DBLP:conf/kr/DilkasB23}, i.e.,
functions and equations that define them.

We write $\mathbb{N}_{0}$ for the set of non-negative integers. In the context
of both algebra and logic, we write $S\sigma$ for a \emph{substitution} $\sigma$
applied to an expression $S$, where
$\sigma = [x_{1} \mapsto y_{1}, x_{2} \mapsto y_{2}, \dots, x_{n} \mapsto y_{n}]$
denotes the replacement of all occurrences of $x_{i}$ with $y_{i}$ for all
$i = 1, \dots, n$.

\subsection{Logic (TODO)}\label{sec:logic}

\todo[inline]{Clarify the differences between the input format and the internal
  format}

\paragraph{The \FO{} Logic (After Skolemization and in a special (prenex, CNF)
  form)}
\begin{itemize}
  \item Although existential quantifiers are supported, here we describe the
        format used internally. During preprocessing, all existential
        quantifiers are eliminated using
        Skolemization~\cite{DBLP:conf/kr/BroeckMD14}, and the formula is
        rewritten into a conjunction of clauses, each of which is in
        \emph{prenex normal form}~\cite{hinman2018fundamentals}.
  \item In the spirit of keeping sorts implicit, we always assume formulas `type
        check' with respect to sorts. For example, if $P(x)$, $P(y)$, and
        $x \ne c$ are all part of the formula (for some predicate $P$, variables
        $x$ and $y$, and constant $c$), then $x$, $y$, and $c$ all have the same
        sort.
  \item A \emph{formula} is a conjunction of clauses.
  \item A \emph{clause} is of the form $\forall x_{1} \in \Delta_{1}\text{.
        }\forall x_{2} \in \Delta_{2}\dots\text{
        }\forall x_{n} \in \Delta_{n}\text{. }\phi(x_{1}, x_{2}, \dots, x_{n})$,
        where $\phi$ is a disjunction of literals that only contain variables
        $x_{1}, \dots, x_{n}$ (and any constants).
  \item We say that a clause is a \emph{(positive) unit clause} if:
        \begin{itemize}
          \item there is only one literal with a predicate, and
          \item it is a positive literal.
        \end{itemize}
  \item A \emph{literal} is either an atom (i.e., a \emph{positive} literal) or
        its negation (i.e., a \emph{negative} literal).
  \item An \emph{atom} is either:
  \begin{itemize}
    \item $P(t_{1}, \dots, t_{m})$ for some predicate $P/m$ and terms
          $t_{1}, \dots, t_{m}$ or
    \item $x=y$ for some terms $x$ and $y$
  \end{itemize}
  \item An atom is \emph{ground} if it contains no variables (i.e., only
        constants).
  \item The \emph{arity} of a predicate is the number of arguments it takes,
        i.e., $m$ in the case of predicate $P$.
  \item When we want to denote a predicate together with its arity, we write
        $P/m$.
  \item A \emph{term} is either a variable or a constant.
  \item Throughout the paper, we use set-theoretic notation, interpreting a
        formula as a set of clauses and a clause as a set of literals. Moreover,
        for readability, clauses written on separate lines are implicitly
        conjoined.
\end{itemize}

\begin{definition}[Model]\label{def:model}
  Let $\phi$ be a formula in \FO{}. For every predicate $p/n$ in $\phi$, let
  ${(\Delta_{i}^{p})}_{i=1}^{n}$ be a list of the corresponding domains (not
  necessarily distinct). Let $\sigma$ be a map from the domains of $\phi$ to
  their interpretations as sets such that:
  \begin{itemize}
    \item the sets are pairwise disjoint, and
    \item the constants in $\phi$ are included in the corresponding domains.
  \end{itemize}
  Then a \emph{structure} of $\phi$ (with respect to $\sigma$) is a set $M$ of
  ground literals defined by adding either $p(\mathbf{t})$ or
  $\neg p(\mathbf{t})$ for every predicate $p/n$ in $\phi$ and $n$-tuple
  $\mathbf{t} \in \prod_{i=1}^{n} \sigma(\Delta_{i}^{p})$. A structure is a
  \emph{model} if it satisfies $\phi$ (see Appendix~A of~Dilkas and
  Belle~\shortcite{DBLP:journals/corr/abs-2306-04189} for more details).
\end{definition}

\begin{definition}[WFOMC]
  Continuing from \cref{def:model}, for every predicate $p/n$ in $\phi$, let
  $w^{+}(p), w^{-}(p) \in \mathbb{R}$ be its (positive and negative)
  \emph{weights}. Unless explicitly specified otherwise, we assume weights to be
  equal to one. The \emph{(symmetric) weighted first-order model count} (WFOMC)
  of $\phi$ (with respect to $\sigma$, $w^{+}$, and $w^{-}$) is the quantity
  \[
    \sum_{M \models \phi} \prod_{p(\mathbf{t}) \in M} w^{+}(p) \prod_{\neg p(\mathbf{t}) \in M} w^{-}(p),
  \]
  where the sum is over all models of $\phi$.
\end{definition}

\begin{table*}
  \centering
  \begin{tabular}{llclll}
    \toprule
    Logic & Sorts & Constants & Variables & Quantifiers & Additional atoms\\
    \midrule
    \FO & one or more & \cmark & unlimited & $\forall$, $\exists$ & $x = y$\\
    \Ctwo & one & \xmark & two & $\forall$, $\exists$, $\exists^{= k}$, $\exists^{\le k}$, $\exists^{\ge k}$ & ---\\
    \UFO & one & \xmark & two & $\forall$ & $|P| = m$\\
    \bottomrule
  \end{tabular}
  \caption[]{A comparison of the three logics used in WFOMC in terms of:
    \begin{enumerate*}[label=(\roman*)]
      \item the number of sorts,
      \item support for constants,
      \item the maximum number of variables,
      \item allowed quantifiers, and
      \item supported atoms in addition to those of the form $P(\mathbf{t})$ for some predicate $P/n$ and $n$-tuple of terms $\mathbf{t}$.
    \end{enumerate*}
    Here:
    \begin{enumerate*}[label=(\roman*)]
      \item $k, m \in \mathbb{N}_{0}$, the latter of which can depend on the domain size,
      \item $P$ is a predicate, and
      \item $x$ and $y$ are terms.
    \end{enumerate*}
  }\label{tbl:logics}
\end{table*}

\paragraph{Three Types of Logics}
\begin{itemize}
  \item See \cref{tbl:logics} for a detailed comparison. The notation introduced
        in the table is standard for \Ctwo{}, new for \UFO{}, and redefined to
        be more specific for \FO{}.
  \item All three logics are function-free.
  \item Domains are always assumed to be finite.
  \item In many-sorted logic, each term is assigned to a \emph{sort}, and each
        predicate $p/n$ is assigned to a sequence of $n$ sorts. Each sort has
        its corresponding domain. In the input formula, all domains are assumed
        to be pairwise disjoint Most of these assignments are typically left
        implicit and can be reconstructed from the quantifiers. For instance,
        $\forall x,y \in \Delta\text{. }P(x, y)$ implies that variables $x$ and
        $y$ have the same sort. On the other hand, $\forall x \in \Delta\text{.
        }\forall y \in \Gamma\text{. } P(x, y)$ implies that $x$ and $y$ have
        different sorts, and it would be improper to have $x = y$ as part of a
        formula.
  \item
        \begin{itemize}
          \item \FO{} is used as the input format for
                \textsc{ForcLift}\footnote{\url{https://github.com/UCLA-StarAI/Forclift}}~\cite{DBLP:conf/ijcai/BroeckTMDR11}
                and its extensions
                \textsc{Crane}\footnote{\url{https://doi.org/10.5281/zenodo.8004077}}~\cite{DBLP:conf/kr/DilkasB23}
                and \Cranetwo{}.
          \item \Ctwo{} is discussed in the literature on
                \textsc{FastWFOMC}~\cite{DBLP:conf/uai/BremenK21} and related
                methods~\cite{DBLP:journals/jair/Kuzelka21,DBLP:conf/aaai/MalhotraS22}
          \item \UFO{} is the input format supported by a version of
                \textsc{FastWFOMC} obtained directly from the authors. Note that
                the publicly available
                version\footnote{\url{https://comp.nus.edu.sg/~tvanbr/software/fastwfomc.tar.gz}}
                does not support any cardinality constraints.
        \end{itemize}
  \item Note that, in the case of \textsc{ForcLift} and its extensions, support
        for a formula as valid input does not imply that the algorithm will be
        able to compile the formula into a circuit or graph suitable for lifted
        model counting. However, it is known that \textsc{ForcLift} compilation
        is guaranteed to succeed on any \FO{} formula without constants and with
        at most two variables~\cite{DBLP:conf/nips/Broeck11}.
\end{itemize}

\begin{example}\label{example:functions}
  Functions
  \begin{itemize}
    \item In \Ctwo: $\forall x \in \Delta\text{.
          }\exists^{=1} y \in \Delta\text{. }P(x, y)$
    \item In \UFO:
          \begin{gather*}
            \forall x, y \in \Delta\text{. }S(x) \lor \neg P(x, y)\\
            |P| = |\Delta|
          \end{gather*}
    \item In \FO:
    \begin{equation}\label[formula]{eq:fo}
      \begin{gathered}
        \forall x \in \Gamma\text{. }\exists y \in \Delta\text{. }P(x, y)\\
        \forall x \in \Gamma\text{. }\forall y, z \in \Delta\text{. }P(x, y) \land P(x, z) \Rightarrow y = z
      \end{gathered}
    \end{equation}
  \end{itemize}

  Note that \cref{eq:fo} is written with two domains instead of one. Clearly,
  the model count does not change whenever $|\Gamma| = |\Delta|$. As was
  previously observed by Dilkas and Belle~\shortcite{DBLP:conf/kr/DilkasB23},
  such a reformulation can help first-order knowledge compilation algorithms
  find efficient solutions.
\end{example}

\subsection{Algebra}\label{sec:algebra}

We write $\expr{}$ for an arbitrary algebraic expression. Note that some terms
have different meanings in the context of algebra as compared to logic. Here, a
\emph{constant} is a non-negative integer. Similarly, a \emph{variable} is
either a parameter of a function or a variable introduced by a summation, e.g.,
$i$ in $\sum_{i=1}^{n} \expr$. A (function) \emph{signature} is
$f(x_{1}, \dots, x_{n})$ (written $f(\mathbf{x})$ for short), where $f$ is an
$n$-ary function, and each $x_{i}$ is a variable. An \emph{equation} is
$f(\mathbf{x}) = \expr{}$, where $f(\mathbf{x})$ is a signature.

\begin{definition}\label{def:basecase}
  Let $f(\mathbf{x})$ be a function call where each $x_{i}$ is either a constant
  or a variable (note that signatures are included in this definition). Then a
  function call $f(\mathbf{y})$ is a \emph{base case} of $f(\mathbf{x})$ if
  $f(\mathbf{y}) = f(\mathbf{x})\sigma$, where $\sigma$ is a substitution that
  replaces one or more $x_{i}$ with a constant.
\end{definition}

\section{Completing the Definitions of Recursive Functions}\label{sec:main}

\begin{algorithm}[t]
  \caption{\protect\CompileWithBaseCases{$\phi$}}\label{alg:compilewithbasecases}
  \KwIn{formula $\phi$}
  \KwOut{set $\mathcal{E}$ of equations}
  $(\mathcal{E}, \mathcal{F}, \mathcal{D}) \gets \Crane{$\phi$}$\;\label{line:first}
  $\mathcal{E} \gets \Simplify{$\mathcal{E}$}$\;\label{line:second}
  \ForEach{base case $f(\mathbf{x}) \in \FindBaseCases{$\mathcal{E}$}$}{
    $\psi \gets \mathcal{F}(f)$\;
    \ForEach{$i$ such that $x_{i} \in \mathbb{N}_{0}$}{
      $\psi \gets \Propagate{$\psi$, $\mathcal{D}(f, i)$, $x_i$}$\;
    }
    $\mathcal{E} \gets \mathcal{E} \cup \CompileWithBaseCases{$\psi$}$\;
  }
\end{algorithm}

\Cref{alg:compilewithbasecases} outlines our overall approach for compiling a
formula into a set of equation that include the required base cases. In short,
we first use the knowledge compilation algorithm of the original
\textsc{Crane}~\cite{DBLP:conf/kr/DilkasB23} to compile the formula into:
\begin{enumerate*}[label=(\roman*)]
  \item set $\mathcal{E}$ of equations,
  \item map $\mathcal{F}$ from function names to formulas, and
  \item map $\mathcal{D}$ from function names and argument indices to domains.
\end{enumerate*}
After some algebraic simplification, $\mathcal{E}$ is passed to the
\FindBaseCases procedure (described in \cref{sec:identifying}) that returns a
set of base cases that we need to find solutions for. For each base case
$f(\mathbf{x})$, we identify the formula associated with $f$ and simplify it
using the \Propagate procedure (described in \cref{sec:simplifying}). The
algorithm then recurses on these simplified formulas and adds the resulting base
case equations to $\mathcal{E}$. \Cref{example:overall} explains
\cref{alg:compilewithbasecases} in more detail.

\begin{example}\label{example:overall}
  Let us consider the following formula (previously examined by Dilkas and
  Belle~\shortcite{DBLP:conf/kr/DilkasB23}) that defines predicate $P$ to be a
  bijection between two sets $\Gamma$ and $\Delta$:
  \[
    \begin{gathered}
      \forall x \in \Gamma\text{. }\exists y \in \Delta\text{. }P(x, y)\\
      \forall y \in \Delta\text{. }\exists x \in \Gamma\text{. }P(x, y)\\
      \forall x \in \Gamma\text{. }\forall y, z \in \Delta\text{. }P(x, y) \land P(x, z) \Rightarrow y = z\\
      \forall x, z \in \Gamma\text{. }\forall y \in \Delta\text{. }P(x, y) \land P(z, y) \Rightarrow x = z.
    \end{gathered}
  \]
  In particular, we examine the first solution that \Cranebfs{} returns for this
  formula.

  After \cref{line:first,line:second}, we have
  \begin{align*}
    \mathcal{E} &= \left\{\,\begin{aligned}f(m, n) &= \sum_{l=0}^{n} \binom{n}{l}{(-1)}^{n-l}g(l, m),\\ g(l, m) &= g(l-1, m) + mg(l-1, m-1)\end{aligned}\,\right\};\\
    \mathcal{D} &= \{\, (f, 1) \mapsto \Gamma, (f, 2) \mapsto \Delta, (g, 1) \mapsto \Delta^{\top}, (g, 2) \mapsto \Gamma \,\},
  \end{align*}
  where $\Delta^{\top}$ is a new domain introduced by \Crane. Then
  \FindBaseCases identifies two base cases: $g(0, m)$ and $g(l, 0)$. In both
  cases, \CompileWithBaseCases recurses on the formula $\mathcal{F}(g)$
  simplified by assuming that one of the domains is empty. In the first case, we
  recurse on the formula $\forall x \in \Gamma\text{. }S(x) \lor \neg S(x)$,
  where $S$ is a predicate introduced by Skolemization with weights
  $w^{+}(S) = 1$ and $w^{-}(S) = -1$. Hence, we get the base case
  $g(0, m) = 0^{m}$. In the case of $g(l, 0)$, \Propagate{$\psi$, $\Gamma$, $0$}
  returns an empty formula, giving us $g(l, 0) = 1$.
\end{example}

Note that these base cases overlap when $l = m = 0$ but are consistent with each
other since $0^{0} = 1$. More generally, let $\phi$ be a formula with two
domains $\Gamma$ and $\Delta$, and let $n, m \in \mathbb{N}_{0}$. Then the model
count of \Propagate{$\phi$, $\Delta$, $n$} assuming $|\Gamma| = m$ is the same
as the model count of \Propagate{$\phi$, $\Gamma$, $m$} assuming $|\Delta| = n$.

\todo[inline]{Can I turn the above into a theorem?}

Finally, we note that the \Simplify procedure plays a crucial role in
simplifying a common algebraic pattern $\sum_{m=0}^{n}[a \le m \le b] f(m)$.
Here:
\begin{enumerate*}[label=(\roman*)]
  \item $n$ is a variable,
  \item $a, b \in \mathbb{N}_{0}$ are constants,
  \item $f$ is an expression that may depend on $m$, and
  \item $[a \le m \le b] =
  \begin{cases}
    1 & \text{if $a \le m \le b$} \\
    0 & \text{otherwise}
  \end{cases}$ is the Iverson bracket.
\end{enumerate*}
\Simplify transforms this pattern into
$f(a) + f(a+1) + \cdots + f(\min\{\, n, b \,\})$. For instance, in the case of
\cref{example:overall}, \Simplify transforms
$g(l, m) = \sum_{k=0}^{m}[0 \le k \le 1]\binom{m}{k}g(l-1, m-k)$ into the
simpler form above.

\todo[inline]{A concluding sentence that introduces the remaining subsections?}

\subsection{Identifying a Sufficient Set of Base Cases}\label{sec:identifying}

\begin{algorithm}[t]
  \caption{\protect\FindBaseCases{$\mathcal{E}$}}\label{alg:findbasecases}
  \KwIn{set $\mathcal{E}$ of equations}
  \KwOut{set $\mathcal{B}$ of base cases}

  $\mathcal{B} \gets \emptyset$\;
  \ForEach{equation $(f(\mathbf{x}) = \expr{}) \in \mathcal{E}$}{
    \ForEach{function call $f(\mathbf{y}) \in \expr{}$}{\label{line:functioncall}
      \ForEach{$y_{i} \in \mathbf{y}$} {
        \uIf{$y_{i} \in \mathbb{N}_{0}$}{
          $\mathcal{B} \gets \mathcal{B} \cup \{\, f(\mathbf{x})[x_{i} \mapsto y_{i}] \,\}$\;
        }
        \ElseIf{$y_{i} = x_{i} - c_{i}$ for some $c_{i} \in \mathbb{N}_{0}$}{
          \For{$j \gets 0$ \KwTo $c_{i} - 1$}{\label{line:lim}
            $\mathcal{B} \gets \mathcal{B} \cup \{\, f(\mathbf{x})[x_{i} \mapsto j] \,\}$\;\label{line:insert}
          }
        }
      }
    }
  }
\end{algorithm}

\Cref{alg:findbasecases} summarises the implementation of \FindBaseCases. For
each recursive call from a function $f$ to itself, we consider two types of
arguments:
\begin{enumerate*}[label=(\roman*)]
  \item constants and
  \item arguments of the form $x_{i} - c_{i}$, where $c_{i} \in \mathbb{N}_{0}$
  is a constant, and $x_{i}$ is the $i$-th argument of the signature of $f$.
\end{enumerate*}
In the former case, we consider a base case specifically for that constant. In
the latter case, we consider a base case for constants from zero up to (but not
including) $c_{i}$. \Cref{thm:halting} below motivates this approach.

\begin{example}
  Consider the recursive function $g$ from \cref{example:overall}.
  \FindBaseCases{$\mathcal{E}$} iterates over two function calls: $g(l-1, m)$
  and $g(l-1, m-1)$. The former produces the base case $g(0, m)$, while the
  latter produces both $g(0, m)$ and $g(l, 0)$.
\end{example}

\todo[inline]{Prove (lots of notes, handwritten and elsewhere)}

\begin{theorem}[Termination]\label{thm:halting}
  Let us assume the following about the input set of equations $\mathcal{E}$:
  \begin{enumerate}
    \item Each function $f$ has exactly one equation with $f$ on the left-hand
          side.\@ We call this equation the \emph{definition} of $f$.
    \item There exists a topological ordering of all functions ${(f_{i})}_{i}$
          such that the definition of $f_{i}$ does not contain function calls to
          $f_{j}$ with $j > i$.\footnote{This condition excludes the possibility
          of mutual recursion and similar cyclic scenarios and is akin to
          stratified logic programs~\cite{DBLP:books/sp/Lloyd87}.}
    \item For every equation $(f(\mathbf{x}) = \expr) \in \mathcal{E}$, every
          recursive function call $f(\mathbf{y}) \in \expr$ satisfies the
          following:
          \begin{itemize}
            \item each $y_{i}$ is either $x_{i} - c_{i}$ or $c_{i}$ for some
                  constant $c_{i} \in \mathbb{N}_{0}$;
            \item there exists $i$ such that $y_{i} = x_{i} - c_{i}$ for some
                  $c_{i} > 0$.
          \end{itemize}
  \end{enumerate}
  Then the set of base cases $\mathcal{B}$ returned by
  \FindBaseCases{$\mathcal{E}$} is \emph{sufficient} for $\mathcal{E}$ in the
  following sense. The evaluation of any function call with non-negative
  arguments terminates as long as the evaluation of base cases is prioritised
  over the corresponding recursive definitions.\footnote{Recall that, as
    previously discussed, the order in which base cases are considered is
    immaterial.}
\end{theorem}

\subsection{Propagating Domain Size Assumptions}\label{sec:simplifying}

\begin{algorithm}[t]
  \caption{\protect\Propagate{$\phi$, $\Delta$, $n$}}\label{alg:propagate}
  \KwIn{formula $\phi$, domain $\Delta$, $n \in \mathbb{N}_{0}$}
  \KwOut{formula $\phi'$}
  $\phi' \gets \emptyset$\;
  \uIf{$n = 0$}{
    \ForEach{clause $C \in \phi$}{
      \lIf{$\Delta \not\in \Doms(C)$}{$\phi' \gets \phi' \cup \{\, C \,\}$}
      \Else{
        $C' \gets \{\, l \in C \mid \Delta \not\in \Doms(l) \,\}$\;
        \If{$C' \ne \emptyset$}{
          $l \gets \text{an arbitrary literal in } C'$\;\label{line:smoothing1}
          $\phi' \gets \phi' \cup \{\, C' \cup \{\, \neg l \,\} \,\} $\;\label{line:smoothing2}
        }
      }
    }
  }
  \Else{
    $D \gets \text{a set of $n$ new constants in $\Delta$}$\;
    \ForEach{clause $C \in \phi$}{
      ${(x_{i})}_{i=1}^{m} \gets \text{the variables in $C$ with domain $\Delta$}$\;
      \lIf{$m = 0$}{$\phi' \gets \phi' \cup \{\, C \,\}$}
      \Else{
        $\phi' \gets \phi' \cup \{\, C[x_{1} \mapsto c_{1}, \dots, x_{m} \mapsto c_{m}] \mid {(c_{i})}_{i=1}^{m} \in D^{m} \,\}$\;
      }
    }
  }
\end{algorithm}

\Propagate (\cref{alg:propagate}) modifies formula $\phi$ with the assumption
that domain $\Delta$ has size $n \in \mathbb{N}_{0}$. In the case of $n=0$, many
clauses become vacuously satisfied and can be removed. In the case of
$n > 0$\footnote{None of the formulas considered in this work had $n > 1$.}, we
perform partial grounding, using constants to replace all variables quantified
over $\Delta$. \Cref{alg:propagate} considers these two cases separately. For a
literal or a clause $C$, we write $\Doms(C)$ to denote the set of corresponding
domains.

In the case of $n = 0$, consider three types of clauses:
\begin{enumerate*}[label=(\roman*)]
  \item those that do not mention $\Delta$,\label{type1}
  \item those in which every literal contains variables quantified over
  $\Delta$, and\label{type2}
  \item those that have some literals with variables quantified over $\Delta$
  and some without.\label{type3}
\end{enumerate*}
\Cref{type1} clauses are transferred to the new formula $\phi'$ unchanged. For
\cref{type2} clauses, $C' = \emptyset$, so these clauses are filtered out. One
might think that the same should be done with \cref{type3} clauses, however,
\cref{line:smoothing1,line:smoothing2} perform a new kind of smoothing, the
explanation of which we defer to \cref{sec:smoothingbase}.

In the case of $n>0$, we introduce $n$ new constants. Consider an arbitrary
clause $C \in \phi$ and let $m \in \mathbb{N}_{0}$ be the number of variables in
$C$ quantified over $\Delta$. If $m=0$, then, similarly to the previous case, we
add $C$ directly to $\phi'$. Otherwise, we add a clause to $\phi'$ with every
possible way of replacing the $m$ variables in $C$ with some combination of the
$n$ new constants.

\begin{example}
  Let us consider the clause $C \equiv \forall x \in \Gamma\text{.
  }\forall y, z \in \Delta\text{. } \neg P(x, y) \lor \neg P(x, z) \lor y=z$.
  Then
  $\Doms(C) = \Doms(\neg P(x, y)) = \Doms(\neg P(x, z)) = \{\, \Gamma, \Delta \,\}$,
  and $\Doms(y=z) = \{\, \Delta \,\}$. A call to \Propagate{$\{\, C \,\}$,
    $\Delta$, $3$} would produce the following formula with nine clauses:
  \begin{align*}
    \forall x \in \Gamma\text{. }\neg P(x, c_{1}) \lor& \neg P(x, c_{1}) \lor c_{1}=c_{1}\\
    \forall x \in \Gamma\text{. }\neg P(x, c_{1}) \lor& \neg P(x, c_{2}) \lor c_{1}=c_{2}\\
    \vdots&\\
    \forall x \in \Gamma\text{. }\neg P(x, c_{3}) \lor& \neg P(x, c_{3}) \lor c_{3}=c_{3},\\
  \end{align*}
  where $c_{1}$, $c_{2}$, and $c_{3}$ are the new constants.
\end{example}

\section{Smoothing (TODO)}

Goal of smoothing: whenever rules such as unit propagation or
inclusion-exclusion (maybe just these two?) eliminate the consideration of some
ground atoms, smoothing nodes should be inserted `at the same level' so that
these ground atoms are still considered when counting. Note that conjunction
nodes are irrelevant here because multiplication is associative. `At the same
level' means that, e.g., if some ground atoms were eliminated from consideration
before/after performing independent partial grounding, then the smoothing node
should also appear before/after the independent partial grounding node.

\todo[inline,caption={}]{
\begin{itemize}
  \item Cite something when introducing the idea of smoothing. Maybe both
        propositional and first-order sources.
  \item Can I prove that the additions to smoothing outlined in the rest of this
        section `do the right thing'?
\end{itemize}
}

\subsection{Smoothing for Base Cases}\label{sec:smoothingbase}

In this section, we motivate and describe \cref{line:smoothing1,line:smoothing2}
of \cref{alg:propagate}. Suppose that \Propagate is called with arguments
$(\phi, \Delta, 0)$, i.e., we are simplifying formula $\phi$ by assuming that
domain $\Delta$ is empty. Informally, if there is a predicate $P$ in $\phi$ that
has nothing to do with domain $\Delta$, the role of smoothing is to preserve all
occurrences of $P$ even if all clauses with $P$ become vacuously satisfied. We
note that the approach presented in this section is far from unique and explain
it via an example below.

\begin{example}\label{example:basecasesmoothing}
  Let $\phi$ be
  \begin{align}
    \forall x \in \Delta\text{. }\forall y, z \in \Gamma&\text{. }Q(x) \lor P(y, z)\label[clause]{eq:example1}\\
    \forall y, z \in \Gamma'&\text{. }P(y, z)\label[clause]{eq:example2},
  \end{align}
  where $\Gamma' \subseteq \Gamma$ is a domain introduced by a compilation rule.
  Note that, as a relation, $P \subseteq \Gamma \times \Gamma$.

  Let us reason by hand about the model count of $\phi$ when
  $\Delta = \emptyset$. Predicate $Q$ can only take one value, i.e.,
  $Q = \emptyset$. The value of $P$ is fixed over $\Gamma' \times \Gamma'$ by
  \cref{eq:example2} but is allowed to vary freely over
  $(\Gamma \times \Gamma) \setminus (\Gamma' \times \Gamma')$ since
  \cref{eq:example1} is vacuously satisfied by all structures. Hence, the right
  model count should be $2^{|\Gamma|^2 - |\Gamma'|^2}$.

  However, without \cref{line:smoothing2}, \Propagate would simplify $\phi$ to
  $\forall y, z \in \Gamma'\text{. }P(y, z)$. Here, $P$ is defined as a subset
  of $\Gamma' \times \Gamma'$. Clearly, this simplified formula has only one
  model: $\{\, P(y, z) \mid y, z \in \Gamma' \,\}$.

  With \cref{line:smoothing2} included, $\phi$ is transformed to
  \begin{gather*}
    \forall y, z \in \Gamma\text{. }P(y, z) \lor \neg P(y, z)\\
    \forall y, z \in \Gamma'\text{. }P(y, z),
  \end{gather*}
  which retains the correct model count.
\end{example}

Note that the choice of $l$ on \cref{line:smoothing1} of \cref{alg:propagate} is
inconsequential because any choice achieves the same goal: constructing a
tautological clause that retains the literals in $C'$.

\subsection{Smoothing the FCG (TODO)}

\todo[inline,caption={}]{
  \begin{itemize}
    \item It seems like I'll need to introduce:
          \begin{itemize}
            \item FCGs
            \item node types (be consistent w.r.t.\ node vs vertex)
            \item their notation
          \end{itemize}
    \item Describe \cref{fig:smoothing1,fig:smoothing2}
    \item Introduce the compilation rules
  \end{itemize}
}

\begin{figure}
  \centering
  \begin{forest}
    for tree={sn edges}
    [$\DR(c \in \Delta)$,name=dr,ellipse,draw,label={right:\textcolor{blue}{3. $\{\, \forall x \in \Delta\text{. }P(x) \,\}$}}
    [$\land$,ellipse,draw,label={left:\textcolor{blue}{2. $\{\, P(c) \,\}$}},label={right:\textcolor{blue}{6. $\{\, P(c), \forall x \in \Delta\text{. }x \ne c \Rightarrow P(x) \,\}$}}
    [$P(c)$,rectangle,draw,fill=green!20,label={272:\textcolor{blue}{1. $\{\, P(c) \,\}$}}]
    [$\CR(\Delta' \gets \Delta \setminus \{\, c \,\})$,ellipse,draw,label={87:\textcolor{blue}{5. $\{\, \forall x \in \Delta\text{. }x \ne c \Rightarrow P(x) \,\}$}}
    [$\Reff(\Delta \mapsto \Delta')$,name=ref,ellipse,draw,label={below:\textcolor{blue}{4. $\{\, \forall x \in \Delta'\text{. }P(x) \,\}$}}]
    ]
    ]
    ]
  \end{forest}
  \caption{An example based on bijection counting (but simplified a lot). The
    arc from the $\Reff$ node to the $\DR$ node is
    omitted.}\label{fig:smoothing1}
\end{figure}

\begin{figure}
  \centering
  \begin{forest}
    for tree={sn edges}
    [$\DR(c \in \Delta)$,name=dr,ellipse,draw
    [$\land$,ellipse,draw,dashed,edge=dashed
    [$P(c)$,rectangle,draw,fill=green!20]
    [$\forall x \in \Delta\text{. }x \ne c \Rightarrow P(x) \lor \neg P(x)$,rectangle,dashed,edge=dashed,draw,fill=blue!20]
    ]
    ]
  \end{forest}
  \caption{An artificial example of a situation when smoothing nodes need to be
    added below a $\DR$ node. The dashed part is added during
    smoothing}\label{fig:smoothing2}
\end{figure}

Smoothing is a two-step process. First, atoms that are still accounted for in
the circuit are propagated upwards. Then, at vertices of certain types, missing
atoms are detected and additional sinks are created to account for them. If left
unchanged, the first step of this process would result in an infinite loop
whenever a cycle is encountered.

\subsection{Stage 1: Propagating Unit Clauses `Upwards' (TODO)}

\begin{description}
  \item[\texttt{Ref}.] During smoothing, when unit clauses are propagated in the
        opposite direction of the FCG arcs (i.e., `upwards'), when visiting a
        \texttt{Ref} node, these clauses are translated using the domain map of
        the \texttt{Ref} node. For example, if the domain map include
        $\Delta \mapsto \Delta'$, and the unit clause mentions $\Delta$, then
        replace it by $\Delta'$.
  \item[Constraint removal.] Do reverse constraint removal. Assuming that
        domain $\Delta$ with constraints $x \ne c$ (for some constant
        $c \in \Delta$) were replaced with domain $\Delta'$, replace each
        $\forall x \in \Delta'\text{. }\phi(x)$ with
        $\forall x \in \Delta\text{. }X \ne c \Rightarrow \phi(x)$.
  \item[Domain recursion.] Suppose the domain recursion node introduces constant
        $c \in \Delta$. For each unit clause received from the child node,
        replace each occurrence of $\phi(c)$ or $\forall x \in \Delta\text{.
        } x \ne c \Rightarrow \phi(x)$ with $\forall x \in \Delta\text{.
        }\phi(x)$. This can be seen as a claim about what ground atoms the
        domain recursion node \emph{should} cover (or a temporary assumption).
        If the relevant subgraph indeed covers those ground atoms, Stage~2 will
        do nothing. Otherwise, smoothing nodes will be added below the domain
        recursion node to cover the difference between what was propagated from
        the domain recursion node and what was received from the child node.
\end{description}

\subsection{Stage 2: Adding Smoothing Nodes (TODO)}

We never need to add smoothing nodes after \texttt{Ref} or constraint removal
nodes. However, for domain recursion we must do the following.

\begin{enumerate}
  \item Whenever the set of unit clauses of the child node contains two formulas
        $\phi(c)$ and $\forall x \in \Delta\text{.
        } x \ne c \Rightarrow \phi(x)$ (i.e., the only difference between the
        two formulas is that one has the constant $c$ whereas the other one has
        a variable $x \ne c$), merge them into $\forall x \in \Delta\text{.
        }\phi(x)$.
  \item Add smoothing nodes below the domain recursion node for the difference
        between the unit clauses assigned to the domain recursion node during
        Stage 1 and the unit clauses of the child node post-processed by the
        step above. For example, if the child node `covers' only $P(c)$, then
        Stage 1 assigns $\forall x \in \Delta\text{. }P(x)$ to the domain
        recursion node. The smoothing node below the domain recursion node then
        has the clause $\forall x \in \Delta\text{. } x \ne c \Rightarrow P(x)$.
\end{enumerate}

\todo[inline]{Can I formally define what is meant by `difference'?}

\section{Generating C++ Code}\label{sec:cpp}

In this section, we describe the last step of \Cranetwo{} outlined in
\cref{fig:overview}: translating the set of equations $\mathcal{E}$ produced by
\CompileWithBaseCases into C++ code. The produced C++ program can then be
compiled and executed with different command-line arguments to compute the model
count of the formula for different (combinations of) domain sizes.

Each equation in $\mathcal{E}$ is compiled into a C++ function, together with
its own cache for memoisation. Let
$e = (f(\mathbf{x}) = \expr{}) \in \mathcal{E}$ be an arbitrary equation, and
let $\mathbf{c} \in \mathbb{N}_{0}^{n}$ represent the arguments of the
corresponding C++ function. The implementation of $e$ consists of three parts.
First, we check whether $\mathbf{c}$ is already in the cache of $e$ (in which
case the cached value is returned). Second, for each base case $f(\mathbf{y})$
of $f(\mathbf{x})$ (as in \cref{def:basecase}), we check whether $\mathbf{c}$
\emph{matches} $\mathbf{y}$, i.e., $c_{i} = y_{i}$ whenever
$y_{i} \in \mathbb{N}_{0}$. In this case, $\mathbf{c}$ is redirected to the C++
function that corresponds to the definition of base case $f(\mathbf{y})$.
Finally, if the above cases fail, we evaluate $\mathbf{c}$ according to
$\expr{}$, store the result in the cache, and return it.

\section{Experimental Evaluation (TODO)}

We compare \Cranetwo{} (in both BFS and greedy modes) with \textsc{FastWFOMC}
and \textsc{ForcLift} on two problems previously considered by Dilkas and
Belle~\shortcite{DBLP:conf/kr/DilkasB23}: the function-counting problem from
\cref{example:functions} and the bijection-counting problem described below.
Note that comparing \Cranetwo{} and \textsc{FastWFOMC} on a larger set of
benchmarks is challenging because there is no automated way to translate a
formula in \FO{} or \Ctwo{} into \UFO{} (or even check if such an encoding is
possible). The experiments were run on an AMD~Ryzen~7~5800H processor with
\SI{16}{\gibi\byte} of memory and Arch Linux~6.8.2-arch2-1 operating system.
\textsc{FastWFOMC} was executed using Python~3.8.19 with Python-FLINT~0.5.0.

\paragraph{Benchmarks (probably for supplementary material).}
\begin{itemize}
  \item Bijections
        \begin{itemize}
          \item In \Ctwo:
                \begin{gather*}
                  \forall x \in \Delta\text{. }\exists^{=1} y \in \Delta\text{. }P(x, y)\\
                  \forall y \in \Delta\text{. }\exists^{=1} x \in \Delta\text{. }P(x, y)
                \end{gather*}
          \item In \UFO:
                \begin{gather*}
                  \forall x, y \in \Delta\text{. }R(x) \lor \neg P(x, y)\\
                  \forall x, y \in \Delta\text{. }S(x) \lor \neg P(y, x)\\
                  |P| = |\Delta|
                \end{gather*}
                with weights $w^{-}(R) = w^{-}(S) = -1$
          \item In \FO: see \cref{example:overall}
        \end{itemize}
\end{itemize}

\begin{figure}
  \centering
  \input{plot}
  \caption{The runtime data of WFOMC algorithms on domains of sizes
    $1, 2, \dots, 35$. Note that the $y$ axis is on a logarithmic
    scale.}\label{fig:plot}
\end{figure}
% TODO: rename permutations to bijections in the plot

\paragraph{Results.}
\begin{itemize}
  \item As shown in \cref{fig:plot}, the runtimes of all compilation-based
        algorithms remain practically constant in contrast to the rapidly
        increasing runtimes of \textsc{FastWFOMC}.
  \item Note that \Cranebfs{} is able to handle more instances than
        \textsc{ForcLift} (e.g., the bijection-counting problem in our
        experiments and other problems in my previous work).
  \item Although the search/compilation part is slower in \Cranetwo{} than in
        \textsc{ForcLift}, the difference is negligible.
  \item The runtimes of three out of four WFOMC algorithms appear constant
        because---for these counting problems and domain sizes---compilation
        time dominates inference time (recall that compilation time is
        independent of domain sizes). Indeed, the maximum inference time of both
        \Cranebfs{} and \Cranegreedy{} across these experiments is
        only \SI{4}{\milli\second}.
  \item The runtimes of \Cranetwo{} have lower variation than those of
        \textsc{ForcLift} because with \textsc{ForcLift} we compile the formula
        anew for each domain size whereas with \Cranetwo{} we compile it once
        and reuse the resulting C++ program for all domain sizes.
  \item As another point of comparison,---in at most
        \SI{41}{\second}---\Cranetwo{} scales up to domains of sizes \num{e4}
        and \num{3e5} in bijection- and function-counting problems, respectively
        (whereas \textsc{FastWFOMC} already takes longer with domains of
        sizes\dots)
\end{itemize}

\todo[inline]{maybe examine \textsc{ForcLift}'s scalability as well}

\todo[inline,caption={}]{
  Some reproducibility requirements to keep in mind:
  \begin{itemize}
    \item A motivation is given for why the experiments are conducted on the
          selected datasets.
    \item All novel datasets introduced in this paper are included in a data
          appendix.
    \item All datasets drawn from the existing literature (potentially including
          authorsâ€™ own previously published work) are accompanied by appropriate
          citations. (mention the counting quantifier paper and my KR paper)
    \item All source code implementing new methods have comments detailing the
          implementation, with references to the paper where each step comes
          from.
    \item This paper formally describes evaluation metrics used and explains the
          motivation for choosing these metrics.
    \item This paper states the number of algorithm runs used to compute each
          reported result.
  \end{itemize}
}

\section{Conclusion (TODO)}

\todo[inline,caption={}]{
  \begin{itemize}
    \item Maybe add some complete examples of C++ programs in the supplementary
          material.
    \item Later on:
          \begin{itemize}
            \item Eliminate (e.g., Emacs) warnings.
            \item must run it by all 3 other coauthors
            \item re-check submission instructions and formatting guidelines
            \item Full stop at the end of a single-sentence caption?
            \item cite the \textsc{Crane} paper (and other algorithms' papers)
                  where necessary
            \item Something to think about that could inspire some kind of
                  theorems: how can I assume that a domain is empty if there are
                  constants associated with it?
            \item consider turning small sections (e.g., Section 5) into
                  subsections of even paragraphs.
            \item Authors may submit a separate PDF with additional information
                  supporting their claims (such as proof details, additional
                  experimental results, further details on experimental design,
                  etc).
          \end{itemize}
  \end{itemize}
}

\clearpage % TODO: temporarary

\bibliographystyle{kr}
\bibliography{paper}

\end{document}
